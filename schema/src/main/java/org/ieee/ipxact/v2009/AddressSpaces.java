//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ieee.ipxact.v2009;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAnyAttribute;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlID;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * <p>Java class for anonymous complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType>
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <element name="addressSpace" maxOccurs="unbounded">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
 *                   <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}blockSize"/>
 *                   <element name="segments" minOccurs="0">
 *                     <complexType>
 *                       <complexContent>
 *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           <sequence>
 *                             <element name="segment" maxOccurs="unbounded">
 *                               <complexType>
 *                                 <complexContent>
 *                                   <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                     <sequence>
 *                                       <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
 *                                       <element name="addressOffset">
 *                                         <complexType>
 *                                           <simpleContent>
 *                                             <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
 *                                               <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
 *                                             </extension>
 *                                           </simpleContent>
 *                                         </complexType>
 *                                       </element>
 *                                       <element name="range">
 *                                         <complexType>
 *                                           <simpleContent>
 *                                             <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
 *                                               <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
 *                                             </extension>
 *                                           </simpleContent>
 *                                         </complexType>
 *                                       </element>
 *                                       <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
 *                                     </sequence>
 *                                   </restriction>
 *                                 </complexContent>
 *                               </complexType>
 *                             </element>
 *                           </sequence>
 *                         </restriction>
 *                       </complexContent>
 *                     </complexType>
 *                   </element>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressUnitBits" minOccurs="0"/>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}executableImage" maxOccurs="unbounded" minOccurs="0"/>
 *                   <element name="localMemoryMap" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}localMemoryMapType" minOccurs="0"/>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}parameters" minOccurs="0"/>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *       </sequence>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "addressSpace"
})
@XmlRootElement(name = "addressSpaces")
public class AddressSpaces {

    /**
     * This defines a logical space, referenced by a bus master.
     * 
     */
    @XmlElement(required = true)
    protected List<AddressSpaces.AddressSpace> addressSpace;

    /**
     * This defines a logical space, referenced by a bus master.
     * 
     * Gets the value of the addressSpace property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the addressSpace property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getAddressSpace().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link AddressSpaces.AddressSpace }
     * </p>
     * 
     * 
     * @return
     *     The value of the addressSpace property.
     */
    public List<AddressSpaces.AddressSpace> getAddressSpace() {
        if (addressSpace == null) {
            addressSpace = new ArrayList<>();
        }
        return this.addressSpace;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
     *         <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}blockSize"/>
     *         <element name="segments" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <sequence>
     *                   <element name="segment" maxOccurs="unbounded">
     *                     <complexType>
     *                       <complexContent>
     *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                           <sequence>
     *                             <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
     *                             <element name="addressOffset">
     *                               <complexType>
     *                                 <simpleContent>
     *                                   <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
     *                                     <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
     *                                   </extension>
     *                                 </simpleContent>
     *                               </complexType>
     *                             </element>
     *                             <element name="range">
     *                               <complexType>
     *                                 <simpleContent>
     *                                   <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
     *                                     <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
     *                                   </extension>
     *                                 </simpleContent>
     *                               </complexType>
     *                             </element>
     *                             <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
     *                           </sequence>
     *                         </restriction>
     *                       </complexContent>
     *                     </complexType>
     *                   </element>
     *                 </sequence>
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addressUnitBits" minOccurs="0"/>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}executableImage" maxOccurs="unbounded" minOccurs="0"/>
     *         <element name="localMemoryMap" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}localMemoryMapType" minOccurs="0"/>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}parameters" minOccurs="0"/>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "name",
        "displayName",
        "description",
        "range",
        "width",
        "segments",
        "addressUnitBits",
        "executableImage",
        "localMemoryMap",
        "parameters",
        "vendorExtensions"
    })
    public static class AddressSpace {

        /**
         * Unique name
         * 
         */
        @XmlElement(required = true)
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String name;
        /**
         * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
         * 
         */
        protected String displayName;
        /**
         * Full description string, typically for documentation
         * 
         */
        protected String description;
        /**
         * The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
         * 					number_of_bits_in_block = spirit:addressUnitBits * spirit:range
         * 					number_of_rows_in_block = number_of_bits_in_block / spirit:width
         * 
         */
        @XmlElement(required = true)
        protected BankedBlockType.Range range;
        /**
         * The bit width of a row in the address block. The range and the width are related by the following formulas:
         * 					number_of_bits_in_block = spirit:addressUnitBits * spirit:range
         * 					number_of_rows_in_block = number_of_bits_in_block / spirit:width
         * 
         */
        @XmlElement(required = true)
        protected BankedBlockType.Width width;
        /**
         * Address segments withing an addressSpace
         * 
         */
        protected AddressSpaces.AddressSpace.Segments segments;
        /**
         * The number of data bits in an addressable unit. The default is byte addressable (8 bits).
         * 
         */
        @XmlSchemaType(name = "positiveInteger")
        protected BigInteger addressUnitBits;
        /**
         * Specifies an executable software image to be loaded into a processors address space. The format of the image is not specified. It could, for example, be an ELF loadfile, or it could be raw binary or ascii hex data for loading directly into a memory model instance.
         * 
         */
        protected List<ExecutableImage> executableImage;
        /**
         * Provides the local memory map of an address space.  Blocks in this memory map are accessable to master interfaces on this component that reference this address space.   They are not accessable to any external master interface.
         * 
         */
        protected LocalMemoryMapType localMemoryMap;
        /**
         * Data specific to this address space.
         * 
         */
        protected Parameters parameters;
        /**
         * Container for vendor specific extensions.
         * 
         */
        protected VendorExtensions vendorExtensions;

        /**
         * Unique name
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getName() {
            return name;
        }

        /**
         * Sets the value of the name property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getName()
         */
        public void setName(String value) {
            this.name = value;
        }

        /**
         * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDisplayName() {
            return displayName;
        }

        /**
         * Sets the value of the displayName property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getDisplayName()
         */
        public void setDisplayName(String value) {
            this.displayName = value;
        }

        /**
         * Full description string, typically for documentation
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDescription() {
            return description;
        }

        /**
         * Sets the value of the description property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getDescription()
         */
        public void setDescription(String value) {
            this.description = value;
        }

        /**
         * The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
         * 					number_of_bits_in_block = spirit:addressUnitBits * spirit:range
         * 					number_of_rows_in_block = number_of_bits_in_block / spirit:width
         * 
         * @return
         *     possible object is
         *     {@link BankedBlockType.Range }
         *     
         */
        public BankedBlockType.Range getRange() {
            return range;
        }

        /**
         * Sets the value of the range property.
         * 
         * @param value
         *     allowed object is
         *     {@link BankedBlockType.Range }
         *     
         * @see #getRange()
         */
        public void setRange(BankedBlockType.Range value) {
            this.range = value;
        }

        /**
         * The bit width of a row in the address block. The range and the width are related by the following formulas:
         * 					number_of_bits_in_block = spirit:addressUnitBits * spirit:range
         * 					number_of_rows_in_block = number_of_bits_in_block / spirit:width
         * 
         * @return
         *     possible object is
         *     {@link BankedBlockType.Width }
         *     
         */
        public BankedBlockType.Width getWidth() {
            return width;
        }

        /**
         * Sets the value of the width property.
         * 
         * @param value
         *     allowed object is
         *     {@link BankedBlockType.Width }
         *     
         * @see #getWidth()
         */
        public void setWidth(BankedBlockType.Width value) {
            this.width = value;
        }

        /**
         * Address segments withing an addressSpace
         * 
         * @return
         *     possible object is
         *     {@link AddressSpaces.AddressSpace.Segments }
         *     
         */
        public AddressSpaces.AddressSpace.Segments getSegments() {
            return segments;
        }

        /**
         * Sets the value of the segments property.
         * 
         * @param value
         *     allowed object is
         *     {@link AddressSpaces.AddressSpace.Segments }
         *     
         * @see #getSegments()
         */
        public void setSegments(AddressSpaces.AddressSpace.Segments value) {
            this.segments = value;
        }

        /**
         * The number of data bits in an addressable unit. The default is byte addressable (8 bits).
         * 
         * @return
         *     possible object is
         *     {@link BigInteger }
         *     
         */
        public BigInteger getAddressUnitBits() {
            return addressUnitBits;
        }

        /**
         * Sets the value of the addressUnitBits property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigInteger }
         *     
         * @see #getAddressUnitBits()
         */
        public void setAddressUnitBits(BigInteger value) {
            this.addressUnitBits = value;
        }

        /**
         * Specifies an executable software image to be loaded into a processors address space. The format of the image is not specified. It could, for example, be an ELF loadfile, or it could be raw binary or ascii hex data for loading directly into a memory model instance.
         * 
         * Gets the value of the executableImage property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the executableImage property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getExecutableImage().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ExecutableImage }
         * </p>
         * 
         * 
         * @return
         *     The value of the executableImage property.
         */
        public List<ExecutableImage> getExecutableImage() {
            if (executableImage == null) {
                executableImage = new ArrayList<>();
            }
            return this.executableImage;
        }

        /**
         * Provides the local memory map of an address space.  Blocks in this memory map are accessable to master interfaces on this component that reference this address space.   They are not accessable to any external master interface.
         * 
         * @return
         *     possible object is
         *     {@link LocalMemoryMapType }
         *     
         */
        public LocalMemoryMapType getLocalMemoryMap() {
            return localMemoryMap;
        }

        /**
         * Sets the value of the localMemoryMap property.
         * 
         * @param value
         *     allowed object is
         *     {@link LocalMemoryMapType }
         *     
         * @see #getLocalMemoryMap()
         */
        public void setLocalMemoryMap(LocalMemoryMapType value) {
            this.localMemoryMap = value;
        }

        /**
         * Data specific to this address space.
         * 
         * @return
         *     possible object is
         *     {@link Parameters }
         *     
         */
        public Parameters getParameters() {
            return parameters;
        }

        /**
         * Sets the value of the parameters property.
         * 
         * @param value
         *     allowed object is
         *     {@link Parameters }
         *     
         * @see #getParameters()
         */
        public void setParameters(Parameters value) {
            this.parameters = value;
        }

        /**
         * Container for vendor specific extensions.
         * 
         * @return
         *     possible object is
         *     {@link VendorExtensions }
         *     
         */
        public VendorExtensions getVendorExtensions() {
            return vendorExtensions;
        }

        /**
         * Sets the value of the vendorExtensions property.
         * 
         * @param value
         *     allowed object is
         *     {@link VendorExtensions }
         *     
         * @see #getVendorExtensions()
         */
        public void setVendorExtensions(VendorExtensions value) {
            this.vendorExtensions = value;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <sequence>
         *         <element name="segment" maxOccurs="unbounded">
         *           <complexType>
         *             <complexContent>
         *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                 <sequence>
         *                   <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
         *                   <element name="addressOffset">
         *                     <complexType>
         *                       <simpleContent>
         *                         <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
         *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
         *                         </extension>
         *                       </simpleContent>
         *                     </complexType>
         *                   </element>
         *                   <element name="range">
         *                     <complexType>
         *                       <simpleContent>
         *                         <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
         *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
         *                         </extension>
         *                       </simpleContent>
         *                     </complexType>
         *                   </element>
         *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
         *                 </sequence>
         *               </restriction>
         *             </complexContent>
         *           </complexType>
         *         </element>
         *       </sequence>
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "segment"
        })
        public static class Segments {

            /**
             * Address segment withing an addressSpace
             * 
             */
            @XmlElement(required = true)
            protected List<AddressSpaces.AddressSpace.Segments.Segment> segment;

            /**
             * Address segment withing an addressSpace
             * 
             * Gets the value of the segment property.
             * 
             * <p>This accessor method returns a reference to the live list,
             * not a snapshot. Therefore any modification you make to the
             * returned list will be present inside the JAXB object.
             * This is why there is not a <CODE>set</CODE> method for the segment property.</p>
             * 
             * <p>
             * For example, to add a new item, do as follows:
             * </p>
             * <pre>
             * getSegment().add(newItem);
             * </pre>
             * 
             * 
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link AddressSpaces.AddressSpace.Segments.Segment }
             * </p>
             * 
             * 
             * @return
             *     The value of the segment property.
             */
            public List<AddressSpaces.AddressSpace.Segments.Segment> getSegment() {
                if (segment == null) {
                    segment = new ArrayList<>();
                }
                return this.segment;
            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <complexContent>
             *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *       <sequence>
             *         <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
             *         <element name="addressOffset">
             *           <complexType>
             *             <simpleContent>
             *               <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
             *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
             *               </extension>
             *             </simpleContent>
             *           </complexType>
             *         </element>
             *         <element name="range">
             *           <complexType>
             *             <simpleContent>
             *               <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
             *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
             *               </extension>
             *             </simpleContent>
             *           </complexType>
             *         </element>
             *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
             *       </sequence>
             *     </restriction>
             *   </complexContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "name",
                "displayName",
                "description",
                "addressOffset",
                "range",
                "vendorExtensions"
            })
            public static class Segment {

                /**
                 * Unique name
                 * 
                 */
                @XmlElement(required = true)
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlSchemaType(name = "Name")
                protected String name;
                /**
                 * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
                 * 
                 */
                protected String displayName;
                /**
                 * Full description string, typically for documentation
                 * 
                 */
                protected String description;
                /**
                 * Address offset of the segment within the containing address space.
                 * 
                 */
                @XmlElement(required = true)
                protected AddressSpaces.AddressSpace.Segments.Segment.AddressOffset addressOffset;
                /**
                 * The address range of asegment.  Expressed as the number of addressable units accessible to the segment.
                 * 
                 */
                @XmlElement(required = true)
                protected AddressSpaces.AddressSpace.Segments.Segment.Range range;
                /**
                 * Container for vendor specific extensions.
                 * 
                 */
                protected VendorExtensions vendorExtensions;

                /**
                 * Unique name
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getName() {
                    return name;
                }

                /**
                 * Sets the value of the name property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getName()
                 */
                public void setName(String value) {
                    this.name = value;
                }

                /**
                 * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getDisplayName() {
                    return displayName;
                }

                /**
                 * Sets the value of the displayName property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getDisplayName()
                 */
                public void setDisplayName(String value) {
                    this.displayName = value;
                }

                /**
                 * Full description string, typically for documentation
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getDescription() {
                    return description;
                }

                /**
                 * Sets the value of the description property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getDescription()
                 */
                public void setDescription(String value) {
                    this.description = value;
                }

                /**
                 * Address offset of the segment within the containing address space.
                 * 
                 * @return
                 *     possible object is
                 *     {@link AddressSpaces.AddressSpace.Segments.Segment.AddressOffset }
                 *     
                 */
                public AddressSpaces.AddressSpace.Segments.Segment.AddressOffset getAddressOffset() {
                    return addressOffset;
                }

                /**
                 * Sets the value of the addressOffset property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link AddressSpaces.AddressSpace.Segments.Segment.AddressOffset }
                 *     
                 * @see #getAddressOffset()
                 */
                public void setAddressOffset(AddressSpaces.AddressSpace.Segments.Segment.AddressOffset value) {
                    this.addressOffset = value;
                }

                /**
                 * The address range of asegment.  Expressed as the number of addressable units accessible to the segment.
                 * 
                 * @return
                 *     possible object is
                 *     {@link AddressSpaces.AddressSpace.Segments.Segment.Range }
                 *     
                 */
                public AddressSpaces.AddressSpace.Segments.Segment.Range getRange() {
                    return range;
                }

                /**
                 * Sets the value of the range property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link AddressSpaces.AddressSpace.Segments.Segment.Range }
                 *     
                 * @see #getRange()
                 */
                public void setRange(AddressSpaces.AddressSpace.Segments.Segment.Range value) {
                    this.range = value;
                }

                /**
                 * Container for vendor specific extensions.
                 * 
                 * @return
                 *     possible object is
                 *     {@link VendorExtensions }
                 *     
                 */
                public VendorExtensions getVendorExtensions() {
                    return vendorExtensions;
                }

                /**
                 * Sets the value of the vendorExtensions property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link VendorExtensions }
                 *     
                 * @see #getVendorExtensions()
                 */
                public void setVendorExtensions(VendorExtensions value) {
                    this.vendorExtensions = value;
                }


                /**
                 * <p>Java class for anonymous complex type</p>.
                 * 
                 * <p>The following schema fragment specifies the expected content contained within this class.</p>
                 * 
                 * <pre>{@code
                 * <complexType>
                 *   <simpleContent>
                 *     <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
                 *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
                 *     </extension>
                 *   </simpleContent>
                 * </complexType>
                 * }</pre>
                 * 
                 * 
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = {
                    "value"
                })
                public static class AddressOffset {

                    /**
                     * A scaled nonnegative integer that consists of the value set {0, 1, ...}.  It is derived from scaledInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                     * 
                     */
                    @XmlValue
                    protected String value;
                    /**
                     * Provides a string used to prompt the user for user-resolved property values.
                     * 
                     */
                    @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String prompt;
                    /**
                     * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                     * 
                     */
                    @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected FormatType format;
                    /**
                     * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                     * 
                     */
                    @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected RangeTypeType rangeType;
                    /**
                     * For user defined properties, refers the choice element enumerating the values to choose from.
                     * 
                     */
                    @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlSchemaType(name = "Name")
                    protected String choiceRef;
                    /**
                     * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                     * 
                     */
                    @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected Float order;
                    /**
                     * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                     * 
                     */
                    @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlSchemaType(name = "NMTOKENS")
                    protected List<String> configGroups;
                    /**
                     * Length of the bit string, required if the format is bitString
                     * 
                     */
                    @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlSchemaType(name = "nonNegativeInteger")
                    protected BigInteger bitStringLength;
                    /**
                     * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                     * 
                     */
                    @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String minimum;
                    /**
                     * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                     * 
                     */
                    @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String maximum;
                    /**
                     * Determines how a property value is resolved.
                     * 
                     */
                    @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected ResolveType resolve;
                    /**
                     * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                     * 
                     */
                    @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlID
                    @XmlSchemaType(name = "ID")
                    protected String id;
                    /**
                     * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                     * 
                     */
                    @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String dependency;
                    @XmlAnyAttribute
                    private Map<QName, String> otherAttributes = new HashMap<>();

                    /**
                     * A scaled nonnegative integer that consists of the value set {0, 1, ...}.  It is derived from scaledInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getValue() {
                        return value;
                    }

                    /**
                     * Sets the value of the value property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getValue()
                     */
                    public void setValue(String value) {
                        this.value = value;
                    }

                    /**
                     * Provides a string used to prompt the user for user-resolved property values.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getPrompt() {
                        return prompt;
                    }

                    /**
                     * Sets the value of the prompt property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getPrompt()
                     */
                    public void setPrompt(String value) {
                        this.prompt = value;
                    }

                    /**
                     * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                     * 
                     * @return
                     *     possible object is
                     *     {@link FormatType }
                     *     
                     */
                    public FormatType getFormat() {
                        if (format == null) {
                            return FormatType.LONG;
                        } else {
                            return format;
                        }
                    }

                    /**
                     * Sets the value of the format property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link FormatType }
                     *     
                     * @see #getFormat()
                     */
                    public void setFormat(FormatType value) {
                        this.format = value;
                    }

                    /**
                     * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                     * 
                     * @return
                     *     possible object is
                     *     {@link RangeTypeType }
                     *     
                     */
                    public RangeTypeType getRangeType() {
                        if (rangeType == null) {
                            return RangeTypeType.FLOAT;
                        } else {
                            return rangeType;
                        }
                    }

                    /**
                     * Sets the value of the rangeType property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link RangeTypeType }
                     *     
                     * @see #getRangeType()
                     */
                    public void setRangeType(RangeTypeType value) {
                        this.rangeType = value;
                    }

                    /**
                     * For user defined properties, refers the choice element enumerating the values to choose from.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getChoiceRef() {
                        return choiceRef;
                    }

                    /**
                     * Sets the value of the choiceRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getChoiceRef()
                     */
                    public void setChoiceRef(String value) {
                        this.choiceRef = value;
                    }

                    /**
                     * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                     * 
                     * @return
                     *     possible object is
                     *     {@link Float }
                     *     
                     */
                    public Float getOrder() {
                        return order;
                    }

                    /**
                     * Sets the value of the order property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link Float }
                     *     
                     * @see #getOrder()
                     */
                    public void setOrder(Float value) {
                        this.order = value;
                    }

                    /**
                     * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                     * 
                     * Gets the value of the configGroups property.
                     * 
                     * <p>This accessor method returns a reference to the live list,
                     * not a snapshot. Therefore any modification you make to the
                     * returned list will be present inside the JAXB object.
                     * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                     * 
                     * <p>
                     * For example, to add a new item, do as follows:
                     * </p>
                     * <pre>
                     * getConfigGroups().add(newItem);
                     * </pre>
                     * 
                     * 
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link String }
                     * </p>
                     * 
                     * 
                     * @return
                     *     The value of the configGroups property.
                     */
                    public List<String> getConfigGroups() {
                        if (configGroups == null) {
                            configGroups = new ArrayList<>();
                        }
                        return this.configGroups;
                    }

                    /**
                     * Length of the bit string, required if the format is bitString
                     * 
                     * @return
                     *     possible object is
                     *     {@link BigInteger }
                     *     
                     */
                    public BigInteger getBitStringLength() {
                        return bitStringLength;
                    }

                    /**
                     * Sets the value of the bitStringLength property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link BigInteger }
                     *     
                     * @see #getBitStringLength()
                     */
                    public void setBitStringLength(BigInteger value) {
                        this.bitStringLength = value;
                    }

                    /**
                     * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getMinimum() {
                        return minimum;
                    }

                    /**
                     * Sets the value of the minimum property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getMinimum()
                     */
                    public void setMinimum(String value) {
                        this.minimum = value;
                    }

                    /**
                     * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getMaximum() {
                        return maximum;
                    }

                    /**
                     * Sets the value of the maximum property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getMaximum()
                     */
                    public void setMaximum(String value) {
                        this.maximum = value;
                    }

                    /**
                     * Determines how a property value is resolved.
                     * 
                     * @return
                     *     possible object is
                     *     {@link ResolveType }
                     *     
                     */
                    public ResolveType getResolve() {
                        if (resolve == null) {
                            return ResolveType.IMMEDIATE;
                        } else {
                            return resolve;
                        }
                    }

                    /**
                     * Sets the value of the resolve property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link ResolveType }
                     *     
                     * @see #getResolve()
                     */
                    public void setResolve(ResolveType value) {
                        this.resolve = value;
                    }

                    /**
                     * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getId() {
                        return id;
                    }

                    /**
                     * Sets the value of the id property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getId()
                     */
                    public void setId(String value) {
                        this.id = value;
                    }

                    /**
                     * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getDependency() {
                        return dependency;
                    }

                    /**
                     * Sets the value of the dependency property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getDependency()
                     */
                    public void setDependency(String value) {
                        this.dependency = value;
                    }

                    /**
                     * Gets a map that contains attributes that aren't bound to any typed property on this class.
                     * 
                     * <p>
                     * the map is keyed by the name of the attribute and 
                     * the value is the string value of the attribute.
                     * 
                     * the map returned by this method is live, and you can add new attribute
                     * by updating the map directly. Because of this design, there's no setter.
                     * 
                     * 
                     * @return
                     *     always non-null
                     */
                    public Map<QName, String> getOtherAttributes() {
                        return otherAttributes;
                    }

                }


                /**
                 * <p>Java class for anonymous complex type</p>.
                 * 
                 * <p>The following schema fragment specifies the expected content contained within this class.</p>
                 * 
                 * <pre>{@code
                 * <complexType>
                 *   <simpleContent>
                 *     <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
                 *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
                 *     </extension>
                 *   </simpleContent>
                 * </complexType>
                 * }</pre>
                 * 
                 * 
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = {
                    "value"
                })
                public static class Range {

                    /**
                     * A scaled positive integer that consists of the value set {1, 2, ...}.  It is derived from scaledNonNegativeInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                     * 
                     */
                    @XmlValue
                    protected String value;
                    /**
                     * Provides a string used to prompt the user for user-resolved property values.
                     * 
                     */
                    @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String prompt;
                    /**
                     * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                     * 
                     */
                    @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected FormatType format;
                    /**
                     * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                     * 
                     */
                    @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected RangeTypeType rangeType;
                    /**
                     * For user defined properties, refers the choice element enumerating the values to choose from.
                     * 
                     */
                    @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlSchemaType(name = "Name")
                    protected String choiceRef;
                    /**
                     * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                     * 
                     */
                    @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected Float order;
                    /**
                     * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                     * 
                     */
                    @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlSchemaType(name = "NMTOKENS")
                    protected List<String> configGroups;
                    /**
                     * Length of the bit string, required if the format is bitString
                     * 
                     */
                    @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlSchemaType(name = "nonNegativeInteger")
                    protected BigInteger bitStringLength;
                    /**
                     * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                     * 
                     */
                    @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String minimum;
                    /**
                     * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                     * 
                     */
                    @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String maximum;
                    /**
                     * Determines how a property value is resolved.
                     * 
                     */
                    @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected ResolveType resolve;
                    /**
                     * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                     * 
                     */
                    @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlID
                    @XmlSchemaType(name = "ID")
                    protected String id;
                    /**
                     * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                     * 
                     */
                    @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                    protected String dependency;
                    @XmlAnyAttribute
                    private Map<QName, String> otherAttributes = new HashMap<>();

                    /**
                     * A scaled positive integer that consists of the value set {1, 2, ...}.  It is derived from scaledNonNegativeInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getValue() {
                        return value;
                    }

                    /**
                     * Sets the value of the value property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getValue()
                     */
                    public void setValue(String value) {
                        this.value = value;
                    }

                    /**
                     * Provides a string used to prompt the user for user-resolved property values.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getPrompt() {
                        return prompt;
                    }

                    /**
                     * Sets the value of the prompt property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getPrompt()
                     */
                    public void setPrompt(String value) {
                        this.prompt = value;
                    }

                    /**
                     * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                     * 
                     * @return
                     *     possible object is
                     *     {@link FormatType }
                     *     
                     */
                    public FormatType getFormat() {
                        if (format == null) {
                            return FormatType.LONG;
                        } else {
                            return format;
                        }
                    }

                    /**
                     * Sets the value of the format property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link FormatType }
                     *     
                     * @see #getFormat()
                     */
                    public void setFormat(FormatType value) {
                        this.format = value;
                    }

                    /**
                     * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                     * 
                     * @return
                     *     possible object is
                     *     {@link RangeTypeType }
                     *     
                     */
                    public RangeTypeType getRangeType() {
                        if (rangeType == null) {
                            return RangeTypeType.FLOAT;
                        } else {
                            return rangeType;
                        }
                    }

                    /**
                     * Sets the value of the rangeType property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link RangeTypeType }
                     *     
                     * @see #getRangeType()
                     */
                    public void setRangeType(RangeTypeType value) {
                        this.rangeType = value;
                    }

                    /**
                     * For user defined properties, refers the choice element enumerating the values to choose from.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getChoiceRef() {
                        return choiceRef;
                    }

                    /**
                     * Sets the value of the choiceRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getChoiceRef()
                     */
                    public void setChoiceRef(String value) {
                        this.choiceRef = value;
                    }

                    /**
                     * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                     * 
                     * @return
                     *     possible object is
                     *     {@link Float }
                     *     
                     */
                    public Float getOrder() {
                        return order;
                    }

                    /**
                     * Sets the value of the order property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link Float }
                     *     
                     * @see #getOrder()
                     */
                    public void setOrder(Float value) {
                        this.order = value;
                    }

                    /**
                     * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                     * 
                     * Gets the value of the configGroups property.
                     * 
                     * <p>This accessor method returns a reference to the live list,
                     * not a snapshot. Therefore any modification you make to the
                     * returned list will be present inside the JAXB object.
                     * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                     * 
                     * <p>
                     * For example, to add a new item, do as follows:
                     * </p>
                     * <pre>
                     * getConfigGroups().add(newItem);
                     * </pre>
                     * 
                     * 
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link String }
                     * </p>
                     * 
                     * 
                     * @return
                     *     The value of the configGroups property.
                     */
                    public List<String> getConfigGroups() {
                        if (configGroups == null) {
                            configGroups = new ArrayList<>();
                        }
                        return this.configGroups;
                    }

                    /**
                     * Length of the bit string, required if the format is bitString
                     * 
                     * @return
                     *     possible object is
                     *     {@link BigInteger }
                     *     
                     */
                    public BigInteger getBitStringLength() {
                        return bitStringLength;
                    }

                    /**
                     * Sets the value of the bitStringLength property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link BigInteger }
                     *     
                     * @see #getBitStringLength()
                     */
                    public void setBitStringLength(BigInteger value) {
                        this.bitStringLength = value;
                    }

                    /**
                     * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getMinimum() {
                        return minimum;
                    }

                    /**
                     * Sets the value of the minimum property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getMinimum()
                     */
                    public void setMinimum(String value) {
                        this.minimum = value;
                    }

                    /**
                     * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getMaximum() {
                        return maximum;
                    }

                    /**
                     * Sets the value of the maximum property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getMaximum()
                     */
                    public void setMaximum(String value) {
                        this.maximum = value;
                    }

                    /**
                     * Determines how a property value is resolved.
                     * 
                     * @return
                     *     possible object is
                     *     {@link ResolveType }
                     *     
                     */
                    public ResolveType getResolve() {
                        if (resolve == null) {
                            return ResolveType.IMMEDIATE;
                        } else {
                            return resolve;
                        }
                    }

                    /**
                     * Sets the value of the resolve property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link ResolveType }
                     *     
                     * @see #getResolve()
                     */
                    public void setResolve(ResolveType value) {
                        this.resolve = value;
                    }

                    /**
                     * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getId() {
                        return id;
                    }

                    /**
                     * Sets the value of the id property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getId()
                     */
                    public void setId(String value) {
                        this.id = value;
                    }

                    /**
                     * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getDependency() {
                        return dependency;
                    }

                    /**
                     * Sets the value of the dependency property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getDependency()
                     */
                    public void setDependency(String value) {
                        this.dependency = value;
                    }

                    /**
                     * Gets a map that contains attributes that aren't bound to any typed property on this class.
                     * 
                     * <p>
                     * the map is keyed by the name of the attribute and 
                     * the value is the string value of the attribute.
                     * 
                     * the map returned by this method is live, and you can add new attribute
                     * by updating the map directly. Because of this design, there's no setter.
                     * 
                     * 
                     * @return
                     *     always non-null
                     */
                    public Map<QName, String> getOtherAttributes() {
                        return otherAttributes;
                    }

                }

            }

        }

    }

}
