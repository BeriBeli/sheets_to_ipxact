//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ieee.ipxact.v2009;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * <p>Java class for anonymous complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType>
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <element name="typeName">
 *           <complexType>
 *             <simpleContent>
 *               <extension base="<http://www.w3.org/2001/XMLSchema>string">
 *                 <attribute name="constrained" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *               </extension>
 *             </simpleContent>
 *           </complexType>
 *         </element>
 *         <element name="typeDefinition" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *         <element name="viewNameRef" type="{http://www.w3.org/2001/XMLSchema}NMTOKEN" maxOccurs="unbounded"/>
 *       </sequence>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "typeName",
    "typeDefinition",
    "viewNameRef"
})
@XmlRootElement(name = "wireTypeDef")
public class WireTypeDef {

    /**
     * The name of the logic type. Examples could be std_logic, std_ulogic, std_logic_vector, sc_logic, ...
     * 
     */
    @XmlElement(required = true)
    protected WireTypeDef.TypeName typeName;
    /**
     * Where the definition of the type is contained. For std_logic, this is contained in IEEE.std_logic_1164.all. For sc_logic, this is contained in systemc.h. For VHDL this is the library and package as defined by the "used" statement. For SystemC and SystemVerilog it is the include file required. For verilog this is not needed.
     * 
     */
    protected List<String> typeDefinition;
    /**
     * A reference to a view name in the file for which this type applies.
     * 
     */
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "NMTOKEN")
    protected List<String> viewNameRef;

    /**
     * The name of the logic type. Examples could be std_logic, std_ulogic, std_logic_vector, sc_logic, ...
     * 
     * @return
     *     possible object is
     *     {@link WireTypeDef.TypeName }
     *     
     */
    public WireTypeDef.TypeName getTypeName() {
        return typeName;
    }

    /**
     * Sets the value of the typeName property.
     * 
     * @param value
     *     allowed object is
     *     {@link WireTypeDef.TypeName }
     *     
     * @see #getTypeName()
     */
    public void setTypeName(WireTypeDef.TypeName value) {
        this.typeName = value;
    }

    /**
     * Where the definition of the type is contained. For std_logic, this is contained in IEEE.std_logic_1164.all. For sc_logic, this is contained in systemc.h. For VHDL this is the library and package as defined by the "used" statement. For SystemC and SystemVerilog it is the include file required. For verilog this is not needed.
     * 
     * Gets the value of the typeDefinition property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the typeDefinition property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getTypeDefinition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * </p>
     * 
     * 
     * @return
     *     The value of the typeDefinition property.
     */
    public List<String> getTypeDefinition() {
        if (typeDefinition == null) {
            typeDefinition = new ArrayList<>();
        }
        return this.typeDefinition;
    }

    /**
     * A reference to a view name in the file for which this type applies.
     * 
     * Gets the value of the viewNameRef property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the viewNameRef property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getViewNameRef().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * </p>
     * 
     * 
     * @return
     *     The value of the viewNameRef property.
     */
    public List<String> getViewNameRef() {
        if (viewNameRef == null) {
            viewNameRef = new ArrayList<>();
        }
        return this.viewNameRef;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.w3.org/2001/XMLSchema>string">
     *       <attribute name="constrained" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class TypeName {

        @XmlValue
        protected String value;
        /**
         * Defines that the type for the port has constrainted the number of bits in the vector
         * 
         */
        @XmlAttribute(name = "constrained", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected Boolean constrained;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setValue(String value) {
            this.value = value;
        }

        /**
         * Defines that the type for the port has constrainted the number of bits in the vector
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isConstrained() {
            if (constrained == null) {
                return false;
            } else {
                return constrained;
            }
        }

        /**
         * Sets the value of the constrained property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         * @see #isConstrained()
         */
        public void setConstrained(Boolean value) {
            this.constrained = value;
        }

    }

}
