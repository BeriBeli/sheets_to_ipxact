//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ieee.ipxact.v2009;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * <p>Java class for anonymous complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType>
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroupOptional"/>
 *         <element name="vector" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="left">
 *                     <complexType>
 *                       <simpleContent>
 *                         <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
 *                         </extension>
 *                       </simpleContent>
 *                     </complexType>
 *                   </element>
 *                   <element name="right">
 *                     <complexType>
 *                       <simpleContent>
 *                         <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
 *                         </extension>
 *                       </simpleContent>
 *                     </complexType>
 *                   </element>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}driveConstraint" minOccurs="0"/>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}loadConstraint" minOccurs="0"/>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}timingConstraint" maxOccurs="unbounded" minOccurs="0"/>
 *       </sequence>
 *       <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}constraintSetId"/>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "name",
    "displayName",
    "description",
    "vector",
    "driveConstraint",
    "loadConstraint",
    "timingConstraint"
})
@XmlRootElement(name = "constraintSet")
public class ConstraintSet {

    /**
     * Unique name
     * 
     */
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String name;
    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
     * 
     */
    protected String displayName;
    /**
     * Full description string, typically for documentation
     * 
     */
    protected String description;
    /**
     * The optional element vector specify the bits of a vector for which the constraints apply. The vaules of left and right must be within the range of the port. If the vector is not specified then the constraints apply to all the bits of the port.
     * 
     */
    protected ConstraintSet.Vector vector;
    /**
     * Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.
     * 
     */
    protected DriveConstraint driveConstraint;
    /**
     * Defines a constraint indicating the type of load on an output port.
     * 
     */
    protected LoadConstraint loadConstraint;
    /**
     * Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.
     * 
     */
    protected List<TimingConstraint> timingConstraint;
    /**
     * Indicates a name for this set of constraints. Constraints are tied to a view using this name in the constraintSetRef element.
     * 
     */
    @XmlAttribute(name = "constraintSetId", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "NMTOKEN")
    protected String constraintSetId;

    /**
     * Unique name
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getName()
     */
    public void setName(String value) {
        this.name = value;
    }

    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Sets the value of the displayName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDisplayName()
     */
    public void setDisplayName(String value) {
        this.displayName = value;
    }

    /**
     * Full description string, typically for documentation
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDescription()
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * The optional element vector specify the bits of a vector for which the constraints apply. The vaules of left and right must be within the range of the port. If the vector is not specified then the constraints apply to all the bits of the port.
     * 
     * @return
     *     possible object is
     *     {@link ConstraintSet.Vector }
     *     
     */
    public ConstraintSet.Vector getVector() {
        return vector;
    }

    /**
     * Sets the value of the vector property.
     * 
     * @param value
     *     allowed object is
     *     {@link ConstraintSet.Vector }
     *     
     * @see #getVector()
     */
    public void setVector(ConstraintSet.Vector value) {
        this.vector = value;
    }

    /**
     * Defines a constraint indicating how an input is to be driven. The preferred methodology is to specify a library cell in technology independent fashion. The implemention tool should assume that the associated port is driven by the specified cell, or that the drive strength of the input port is indicated by the specified resistance value.
     * 
     * @return
     *     possible object is
     *     {@link DriveConstraint }
     *     
     */
    public DriveConstraint getDriveConstraint() {
        return driveConstraint;
    }

    /**
     * Sets the value of the driveConstraint property.
     * 
     * @param value
     *     allowed object is
     *     {@link DriveConstraint }
     *     
     * @see #getDriveConstraint()
     */
    public void setDriveConstraint(DriveConstraint value) {
        this.driveConstraint = value;
    }

    /**
     * Defines a constraint indicating the type of load on an output port.
     * 
     * @return
     *     possible object is
     *     {@link LoadConstraint }
     *     
     */
    public LoadConstraint getLoadConstraint() {
        return loadConstraint;
    }

    /**
     * Sets the value of the loadConstraint property.
     * 
     * @param value
     *     allowed object is
     *     {@link LoadConstraint }
     *     
     * @see #getLoadConstraint()
     */
    public void setLoadConstraint(LoadConstraint value) {
        this.loadConstraint = value;
    }

    /**
     * Defines a timing constraint for the associated port. The constraint is relative to the clock specified by the clockName attribute. The clockEdge indicates which clock edge the constraint is associated with (default is rising edge). The delayType attribute can be specified to further refine the constraint.
     * 
     * Gets the value of the timingConstraint property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the timingConstraint property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getTimingConstraint().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TimingConstraint }
     * </p>
     * 
     * 
     * @return
     *     The value of the timingConstraint property.
     */
    public List<TimingConstraint> getTimingConstraint() {
        if (timingConstraint == null) {
            timingConstraint = new ArrayList<>();
        }
        return this.timingConstraint;
    }

    /**
     * Indicates a name for this set of constraints. Constraints are tied to a view using this name in the constraintSetRef element.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getConstraintSetId() {
        if (constraintSetId == null) {
            return "default";
        } else {
            return constraintSetId;
        }
    }

    /**
     * Sets the value of the constraintSetId property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getConstraintSetId()
     */
    public void setConstraintSetId(String value) {
        this.constraintSetId = value;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="left">
     *           <complexType>
     *             <simpleContent>
     *               <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
     *               </extension>
     *             </simpleContent>
     *           </complexType>
     *         </element>
     *         <element name="right">
     *           <complexType>
     *             <simpleContent>
     *               <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
     *               </extension>
     *             </simpleContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "left",
        "right"
    })
    public static class Vector {

        /**
         * The optional elements left and right can be used to select a bit-slice of a vector.
         * 
         */
        @XmlElement(required = true)
        protected ConstraintSet.Vector.Left left;
        /**
         * The optional elements left and right can be used to select a bit-slice of a vector.
         * 
         */
        @XmlElement(required = true)
        protected ConstraintSet.Vector.Right right;

        /**
         * The optional elements left and right can be used to select a bit-slice of a vector.
         * 
         * @return
         *     possible object is
         *     {@link ConstraintSet.Vector.Left }
         *     
         */
        public ConstraintSet.Vector.Left getLeft() {
            return left;
        }

        /**
         * Sets the value of the left property.
         * 
         * @param value
         *     allowed object is
         *     {@link ConstraintSet.Vector.Left }
         *     
         * @see #getLeft()
         */
        public void setLeft(ConstraintSet.Vector.Left value) {
            this.left = value;
        }

        /**
         * The optional elements left and right can be used to select a bit-slice of a vector.
         * 
         * @return
         *     possible object is
         *     {@link ConstraintSet.Vector.Right }
         *     
         */
        public ConstraintSet.Vector.Right getRight() {
            return right;
        }

        /**
         * Sets the value of the right property.
         * 
         * @param value
         *     allowed object is
         *     {@link ConstraintSet.Vector.Right }
         *     
         * @see #getRight()
         */
        public void setRight(ConstraintSet.Vector.Right value) {
            this.right = value;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <simpleContent>
         *     <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
         *     </extension>
         *   </simpleContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "value"
        })
        public static class Left {

            @XmlValue
            @XmlSchemaType(name = "nonNegativeInteger")
            protected BigInteger value;

            /**
             * Gets the value of the value property.
             * 
             * @return
             *     possible object is
             *     {@link BigInteger }
             *     
             */
            public BigInteger getValue() {
                return value;
            }

            /**
             * Sets the value of the value property.
             * 
             * @param value
             *     allowed object is
             *     {@link BigInteger }
             *     
             */
            public void setValue(BigInteger value) {
                this.value = value;
            }

        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <simpleContent>
         *     <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
         *     </extension>
         *   </simpleContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "value"
        })
        public static class Right {

            @XmlValue
            @XmlSchemaType(name = "nonNegativeInteger")
            protected BigInteger value;

            /**
             * Gets the value of the value property.
             * 
             * @return
             *     possible object is
             *     {@link BigInteger }
             *     
             */
            public BigInteger getValue() {
                return value;
            }

            /**
             * Sets the value of the value property.
             * 
             * @param value
             *     allowed object is
             *     {@link BigInteger }
             *     
             */
            public void setValue(BigInteger value) {
                this.value = value;
            }

        }

    }

}
