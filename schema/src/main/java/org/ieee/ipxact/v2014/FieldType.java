//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ieee.ipxact.v2014;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlID;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * A field within a register
 * 
 * <p>Java class for fieldType complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="fieldType">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameGroup"/>
 *         <element name="accessHandles" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence maxOccurs="unbounded">
 *                   <element name="accessHandle" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nonIndexedLeafAccessHandle"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}isPresent" minOccurs="0"/>
 *         <element name="bitOffset" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}unsignedIntExpression"/>
 *         <element name="resets" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}reset" maxOccurs="unbounded"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fieldDefinitionGroup"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions" minOccurs="0"/>
 *       </sequence>
 *       <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}id.att"/>
 *       <attribute name="fieldID" type="{http://www.w3.org/2001/XMLSchema}Name" />
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "fieldType", propOrder = {
    "name",
    "displayName",
    "description",
    "accessHandles",
    "isPresent",
    "bitOffset",
    "resets",
    "typeIdentifier",
    "bitWidth",
    "_volatile",
    "access",
    "enumeratedValues",
    "modifiedWriteValue",
    "writeValueConstraint",
    "readAction",
    "testable",
    "reserved",
    "parameters",
    "vendorExtensions"
})
public class FieldType {

    /**
     * Unique name
     * 
     */
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String name;
    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.
     * 
     */
    protected String displayName;
    /**
     * Full description string, typically for documentation
     * 
     */
    protected String description;
    protected FieldType.AccessHandles accessHandles;
    /**
     * Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")
     * 
     */
    protected UnsignedBitExpression isPresent;
    /**
     * Offset of this field's bit 0 from bit 0 of the register.
     * 
     */
    @XmlElement(required = true)
    protected UnsignedIntExpression bitOffset;
    protected FieldType.Resets resets;
    /**
     * Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.
     * 
     */
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String typeIdentifier;
    /**
     * Width of the field in bits.
     * 
     */
    @XmlElement(required = true)
    protected UnsignedPositiveIntExpression bitWidth;
    /**
     * Indicates whether the data is volatile. The presumed value is 'false' if not present.
     * 
     */
    @XmlElement(name = "volatile", defaultValue = "false")
    protected Boolean _volatile;
    /**
     * Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.
     * 
     */
    @XmlSchemaType(name = "token")
    protected AccessType access;
    /**
     * Enumerates specific values that can be assigned to the bit field.
     * 
     */
    protected EnumeratedValues enumeratedValues;
    /**
     * If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.
     * 
     */
    protected FieldType.ModifiedWriteValue modifiedWriteValue;
    /**
     * The legal values that may be written to a field. If not specified the legal values are not specified.
     * 
     */
    protected WriteValueConstraintType writeValueConstraint;
    /**
     * A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.
     * 
     */
    protected FieldType.ReadAction readAction;
    /**
     * Can the field be tested with an automated register test routine. The presumed value is true if not specified.
     * 
     */
    protected FieldType.Testable testable;
    /**
     * Indicates that the field should be documented as reserved. The presumed value is 'false' if not present.
     * 
     */
    @XmlElement(defaultValue = "false")
    protected UnsignedBitExpression reserved;
    /**
     * A collection of parameters and associated value assertions.
     * 
     */
    protected Parameters parameters;
    /**
     * Container for vendor specific extensions.
     * 
     */
    protected VendorExtensions vendorExtensions;
    /**
     * A unique identifier within a component for a field.
     * 
     */
    @XmlAttribute(name = "fieldID")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String fieldID;
    /**
     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
     * 
     */
    @XmlAttribute(name = "id", namespace = "http://www.w3.org/XML/1998/namespace")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected String id;

    /**
     * Unique name
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getName()
     */
    public void setName(String value) {
        this.name = value;
    }

    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Sets the value of the displayName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDisplayName()
     */
    public void setDisplayName(String value) {
        this.displayName = value;
    }

    /**
     * Full description string, typically for documentation
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDescription()
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * Gets the value of the accessHandles property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.AccessHandles }
     *     
     */
    public FieldType.AccessHandles getAccessHandles() {
        return accessHandles;
    }

    /**
     * Sets the value of the accessHandles property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.AccessHandles }
     *     
     */
    public void setAccessHandles(FieldType.AccessHandles value) {
        this.accessHandles = value;
    }

    /**
     * Expression that determines whether the enclosing element should be treated as present (expression evaluates to "true") or disregarded (expression evalutes to "false")
     * 
     * @return
     *     possible object is
     *     {@link UnsignedBitExpression }
     *     
     */
    public UnsignedBitExpression getIsPresent() {
        return isPresent;
    }

    /**
     * Sets the value of the isPresent property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedBitExpression }
     *     
     * @see #getIsPresent()
     */
    public void setIsPresent(UnsignedBitExpression value) {
        this.isPresent = value;
    }

    /**
     * Offset of this field's bit 0 from bit 0 of the register.
     * 
     * @return
     *     possible object is
     *     {@link UnsignedIntExpression }
     *     
     */
    public UnsignedIntExpression getBitOffset() {
        return bitOffset;
    }

    /**
     * Sets the value of the bitOffset property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedIntExpression }
     *     
     * @see #getBitOffset()
     */
    public void setBitOffset(UnsignedIntExpression value) {
        this.bitOffset = value;
    }

    /**
     * Gets the value of the resets property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.Resets }
     *     
     */
    public FieldType.Resets getResets() {
        return resets;
    }

    /**
     * Sets the value of the resets property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.Resets }
     *     
     */
    public void setResets(FieldType.Resets value) {
        this.resets = value;
    }

    /**
     * Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getTypeIdentifier() {
        return typeIdentifier;
    }

    /**
     * Sets the value of the typeIdentifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getTypeIdentifier()
     */
    public void setTypeIdentifier(String value) {
        this.typeIdentifier = value;
    }

    /**
     * Width of the field in bits.
     * 
     * @return
     *     possible object is
     *     {@link UnsignedPositiveIntExpression }
     *     
     */
    public UnsignedPositiveIntExpression getBitWidth() {
        return bitWidth;
    }

    /**
     * Sets the value of the bitWidth property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedPositiveIntExpression }
     *     
     * @see #getBitWidth()
     */
    public void setBitWidth(UnsignedPositiveIntExpression value) {
        this.bitWidth = value;
    }

    /**
     * Indicates whether the data is volatile. The presumed value is 'false' if not present.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isVolatile() {
        return _volatile;
    }

    /**
     * Sets the value of the volatile property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     * @see #isVolatile()
     */
    public void setVolatile(Boolean value) {
        this._volatile = value;
    }

    /**
     * Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.
     * 
     * @return
     *     possible object is
     *     {@link AccessType }
     *     
     */
    public AccessType getAccess() {
        return access;
    }

    /**
     * Sets the value of the access property.
     * 
     * @param value
     *     allowed object is
     *     {@link AccessType }
     *     
     * @see #getAccess()
     */
    public void setAccess(AccessType value) {
        this.access = value;
    }

    /**
     * Enumerates specific values that can be assigned to the bit field.
     * 
     * @return
     *     possible object is
     *     {@link EnumeratedValues }
     *     
     */
    public EnumeratedValues getEnumeratedValues() {
        return enumeratedValues;
    }

    /**
     * Sets the value of the enumeratedValues property.
     * 
     * @param value
     *     allowed object is
     *     {@link EnumeratedValues }
     *     
     * @see #getEnumeratedValues()
     */
    public void setEnumeratedValues(EnumeratedValues value) {
        this.enumeratedValues = value;
    }

    /**
     * If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.ModifiedWriteValue }
     *     
     */
    public FieldType.ModifiedWriteValue getModifiedWriteValue() {
        return modifiedWriteValue;
    }

    /**
     * Sets the value of the modifiedWriteValue property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.ModifiedWriteValue }
     *     
     * @see #getModifiedWriteValue()
     */
    public void setModifiedWriteValue(FieldType.ModifiedWriteValue value) {
        this.modifiedWriteValue = value;
    }

    /**
     * The legal values that may be written to a field. If not specified the legal values are not specified.
     * 
     * @return
     *     possible object is
     *     {@link WriteValueConstraintType }
     *     
     */
    public WriteValueConstraintType getWriteValueConstraint() {
        return writeValueConstraint;
    }

    /**
     * Sets the value of the writeValueConstraint property.
     * 
     * @param value
     *     allowed object is
     *     {@link WriteValueConstraintType }
     *     
     * @see #getWriteValueConstraint()
     */
    public void setWriteValueConstraint(WriteValueConstraintType value) {
        this.writeValueConstraint = value;
    }

    /**
     * A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.ReadAction }
     *     
     */
    public FieldType.ReadAction getReadAction() {
        return readAction;
    }

    /**
     * Sets the value of the readAction property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.ReadAction }
     *     
     * @see #getReadAction()
     */
    public void setReadAction(FieldType.ReadAction value) {
        this.readAction = value;
    }

    /**
     * Can the field be tested with an automated register test routine. The presumed value is true if not specified.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.Testable }
     *     
     */
    public FieldType.Testable getTestable() {
        return testable;
    }

    /**
     * Sets the value of the testable property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.Testable }
     *     
     * @see #getTestable()
     */
    public void setTestable(FieldType.Testable value) {
        this.testable = value;
    }

    /**
     * Indicates that the field should be documented as reserved. The presumed value is 'false' if not present.
     * 
     * @return
     *     possible object is
     *     {@link UnsignedBitExpression }
     *     
     */
    public UnsignedBitExpression getReserved() {
        return reserved;
    }

    /**
     * Sets the value of the reserved property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedBitExpression }
     *     
     * @see #getReserved()
     */
    public void setReserved(UnsignedBitExpression value) {
        this.reserved = value;
    }

    /**
     * A collection of parameters and associated value assertions.
     * 
     * @return
     *     possible object is
     *     {@link Parameters }
     *     
     */
    public Parameters getParameters() {
        return parameters;
    }

    /**
     * Sets the value of the parameters property.
     * 
     * @param value
     *     allowed object is
     *     {@link Parameters }
     *     
     * @see #getParameters()
     */
    public void setParameters(Parameters value) {
        this.parameters = value;
    }

    /**
     * Container for vendor specific extensions.
     * 
     * @return
     *     possible object is
     *     {@link VendorExtensions }
     *     
     */
    public VendorExtensions getVendorExtensions() {
        return vendorExtensions;
    }

    /**
     * Sets the value of the vendorExtensions property.
     * 
     * @param value
     *     allowed object is
     *     {@link VendorExtensions }
     *     
     * @see #getVendorExtensions()
     */
    public void setVendorExtensions(VendorExtensions value) {
        this.vendorExtensions = value;
    }

    /**
     * A unique identifier within a component for a field.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFieldID() {
        return fieldID;
    }

    /**
     * Sets the value of the fieldID property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getFieldID()
     */
    public void setFieldID(String value) {
        this.fieldID = value;
    }

    /**
     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getId()
     */
    public void setId(String value) {
        this.id = value;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence maxOccurs="unbounded">
     *         <element name="accessHandle" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nonIndexedLeafAccessHandle"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "accessHandle"
    })
    public static class AccessHandles {

        @XmlElement(required = true)
        protected List<NonIndexedLeafAccessHandle> accessHandle;

        /**
         * Gets the value of the accessHandle property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the accessHandle property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getAccessHandle().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link NonIndexedLeafAccessHandle }
         * </p>
         * 
         * 
         * @return
         *     The value of the accessHandle property.
         */
        public List<NonIndexedLeafAccessHandle> getAccessHandle() {
            if (accessHandle == null) {
                accessHandle = new ArrayList<>();
            }
            return this.accessHandle;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.accellera.org/XMLSchema/IPXACT/1685-2014>modifiedWriteValueType">
     *       <attribute name="modify" type="{http://www.w3.org/2001/XMLSchema}Name" />
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class ModifiedWriteValue {

        @XmlValue
        protected ModifiedWriteValueType value;
        @XmlAttribute(name = "modify")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String modify;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link ModifiedWriteValueType }
         *     
         */
        public ModifiedWriteValueType getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link ModifiedWriteValueType }
         *     
         */
        public void setValue(ModifiedWriteValueType value) {
            this.value = value;
        }

        /**
         * Gets the value of the modify property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getModify() {
            return modify;
        }

        /**
         * Sets the value of the modify property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setModify(String value) {
            this.modify = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.accellera.org/XMLSchema/IPXACT/1685-2014>readActionType">
     *       <attribute name="modify" type="{http://www.w3.org/2001/XMLSchema}Name" />
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class ReadAction {

        @XmlValue
        protected ReadActionType value;
        @XmlAttribute(name = "modify")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String modify;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link ReadActionType }
         *     
         */
        public ReadActionType getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link ReadActionType }
         *     
         */
        public void setValue(ReadActionType value) {
            this.value = value;
        }

        /**
         * Gets the value of the modify property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getModify() {
            return modify;
        }

        /**
         * Sets the value of the modify property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setModify(String value) {
            this.modify = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}reset" maxOccurs="unbounded"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "reset"
    })
    public static class Resets {

        /**
         * BitField reset value
         * 
         */
        @XmlElement(required = true)
        protected List<Reset> reset;

        /**
         * BitField reset value
         * 
         * Gets the value of the reset property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the reset property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getReset().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Reset }
         * </p>
         * 
         * 
         * @return
         *     The value of the reset property.
         */
        public List<Reset> getReset() {
            if (reset == null) {
                reset = new ArrayList<>();
            }
            return this.reset;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.w3.org/2001/XMLSchema>boolean">
     *       <attribute name="testConstraint" default="unconstrained">
     *         <simpleType>
     *           <restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *             <enumeration value="unconstrained"/>
     *             <enumeration value="restore"/>
     *             <enumeration value="writeAsRead"/>
     *             <enumeration value="readOnly"/>
     *           </restriction>
     *         </simpleType>
     *       </attribute>
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class Testable {

        @XmlValue
        protected boolean value;
        /**
         * Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.
         * 
         */
        @XmlAttribute(name = "testConstraint")
        protected String testConstraint;

        /**
         * Gets the value of the value property.
         * 
         */
        public boolean isValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         */
        public void setValue(boolean value) {
            this.value = value;
        }

        /**
         * Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTestConstraint() {
            if (testConstraint == null) {
                return "unconstrained";
            } else {
                return testConstraint;
            }
        }

        /**
         * Sets the value of the testConstraint property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getTestConstraint()
         */
        public void setTestConstraint(String value) {
            this.testConstraint = value;
        }

    }

}
