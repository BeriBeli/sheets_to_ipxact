//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.ieee.ipxact.v2022;

import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;


/**
 * Transactional port type.
 * 
 * <p>Java class for abstractorPortTransactionalType complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="abstractorPortTransactionalType">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}initiative"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}kind" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}busWidth" minOccurs="0"/>
 *         <element name="qualifier" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}qualifierType" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}protocol" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}transTypeDefs" minOccurs="0"/>
 *         <element name="connection" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="maxConnections" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedIntExpression" minOccurs="0"/>
 *                   <element name="minConnections" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedIntExpression" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *       </sequence>
 *       <attribute name="allLogicalInitiativesAllowed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "abstractorPortTransactionalType", propOrder = {
    "initiative",
    "kind",
    "busWidth",
    "qualifier",
    "protocol",
    "transTypeDefs",
    "connection"
})
public class AbstractorPortTransactionalType {

    /**
     * Defines how the port accesses this service.
     * 
     */
    @XmlElement(required = true)
    @XmlSchemaType(name = "string")
    protected InitiativeType initiative;
    /**
     * Define the kind of transactional port
     * 
     */
    protected Kind kind;
    /**
     * Defines the bus width in bits.This can be the result of an expression.
     * 
     */
    protected UnsignedIntExpression busWidth;
    /**
     * The type of information this port carries A transactional port can carry both address and data information.
     * 
     */
    protected QualifierType qualifier;
    /**
     * Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets
     * 
     */
    protected Protocol protocol;
    /**
     * Definition of the port type expressed in the default language for this port (i.e. SystemC or SystemV).
     * 
     */
    protected TransTypeDefs transTypeDefs;
    /**
     * Bounds number of legal connections.
     * 
     */
    protected AbstractorPortTransactionalType.Connection connection;
    /**
     * True if logical ports with different initiatives from the physical port initiative may be mapped onto this port. Forbidden for phantom ports, which always allow logical ports with all initiatives value to be mapped onto the physical port. Also ignored for "both" ports, since any logical port may be mapped to a physical "both" port.
     * 
     */
    @XmlAttribute(name = "allLogicalInitiativesAllowed")
    protected Boolean allLogicalInitiativesAllowed;

    /**
     * Defines how the port accesses this service.
     * 
     * @return
     *     possible object is
     *     {@link InitiativeType }
     *     
     */
    public InitiativeType getInitiative() {
        return initiative;
    }

    /**
     * Sets the value of the initiative property.
     * 
     * @param value
     *     allowed object is
     *     {@link InitiativeType }
     *     
     * @see #getInitiative()
     */
    public void setInitiative(InitiativeType value) {
        this.initiative = value;
    }

    /**
     * Define the kind of transactional port
     * 
     * @return
     *     possible object is
     *     {@link Kind }
     *     
     */
    public Kind getKind() {
        return kind;
    }

    /**
     * Sets the value of the kind property.
     * 
     * @param value
     *     allowed object is
     *     {@link Kind }
     *     
     * @see #getKind()
     */
    public void setKind(Kind value) {
        this.kind = value;
    }

    /**
     * Defines the bus width in bits.This can be the result of an expression.
     * 
     * @return
     *     possible object is
     *     {@link UnsignedIntExpression }
     *     
     */
    public UnsignedIntExpression getBusWidth() {
        return busWidth;
    }

    /**
     * Sets the value of the busWidth property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedIntExpression }
     *     
     * @see #getBusWidth()
     */
    public void setBusWidth(UnsignedIntExpression value) {
        this.busWidth = value;
    }

    /**
     * The type of information this port carries A transactional port can carry both address and data information.
     * 
     * @return
     *     possible object is
     *     {@link QualifierType }
     *     
     */
    public QualifierType getQualifier() {
        return qualifier;
    }

    /**
     * Sets the value of the qualifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link QualifierType }
     *     
     * @see #getQualifier()
     */
    public void setQualifier(QualifierType value) {
        this.qualifier = value;
    }

    /**
     * Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets
     * 
     * @return
     *     possible object is
     *     {@link Protocol }
     *     
     */
    public Protocol getProtocol() {
        return protocol;
    }

    /**
     * Sets the value of the protocol property.
     * 
     * @param value
     *     allowed object is
     *     {@link Protocol }
     *     
     * @see #getProtocol()
     */
    public void setProtocol(Protocol value) {
        this.protocol = value;
    }

    /**
     * Definition of the port type expressed in the default language for this port (i.e. SystemC or SystemV).
     * 
     * @return
     *     possible object is
     *     {@link TransTypeDefs }
     *     
     */
    public TransTypeDefs getTransTypeDefs() {
        return transTypeDefs;
    }

    /**
     * Sets the value of the transTypeDefs property.
     * 
     * @param value
     *     allowed object is
     *     {@link TransTypeDefs }
     *     
     * @see #getTransTypeDefs()
     */
    public void setTransTypeDefs(TransTypeDefs value) {
        this.transTypeDefs = value;
    }

    /**
     * Bounds number of legal connections.
     * 
     * @return
     *     possible object is
     *     {@link AbstractorPortTransactionalType.Connection }
     *     
     */
    public AbstractorPortTransactionalType.Connection getConnection() {
        return connection;
    }

    /**
     * Sets the value of the connection property.
     * 
     * @param value
     *     allowed object is
     *     {@link AbstractorPortTransactionalType.Connection }
     *     
     * @see #getConnection()
     */
    public void setConnection(AbstractorPortTransactionalType.Connection value) {
        this.connection = value;
    }

    /**
     * True if logical ports with different initiatives from the physical port initiative may be mapped onto this port. Forbidden for phantom ports, which always allow logical ports with all initiatives value to be mapped onto the physical port. Also ignored for "both" ports, since any logical port may be mapped to a physical "both" port.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAllLogicalInitiativesAllowed() {
        if (allLogicalInitiativesAllowed == null) {
            return false;
        } else {
            return allLogicalInitiativesAllowed;
        }
    }

    /**
     * Sets the value of the allLogicalInitiativesAllowed property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     * @see #isAllLogicalInitiativesAllowed()
     */
    public void setAllLogicalInitiativesAllowed(Boolean value) {
        this.allLogicalInitiativesAllowed = value;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="maxConnections" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedIntExpression" minOccurs="0"/>
     *         <element name="minConnections" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedIntExpression" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "maxConnections",
        "minConnections"
    })
    public static class Connection {

        /**
         * Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.
         * 
         */
        @XmlElement(defaultValue = "0")
        protected UnsignedIntExpression maxConnections;
        /**
         * Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.
         * 
         */
        @XmlElement(defaultValue = "1")
        protected UnsignedIntExpression minConnections;

        /**
         * Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.
         * 
         * @return
         *     possible object is
         *     {@link UnsignedIntExpression }
         *     
         */
        public UnsignedIntExpression getMaxConnections() {
            return maxConnections;
        }

        /**
         * Sets the value of the maxConnections property.
         * 
         * @param value
         *     allowed object is
         *     {@link UnsignedIntExpression }
         *     
         * @see #getMaxConnections()
         */
        public void setMaxConnections(UnsignedIntExpression value) {
            this.maxConnections = value;
        }

        /**
         * Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.
         * 
         * @return
         *     possible object is
         *     {@link UnsignedIntExpression }
         *     
         */
        public UnsignedIntExpression getMinConnections() {
            return minConnections;
        }

        /**
         * Sets the value of the minConnections property.
         * 
         * @param value
         *     allowed object is
         *     {@link UnsignedIntExpression }
         *     
         * @see #getMinConnections()
         */
        public void setMinConnections(UnsignedIntExpression value) {
            this.minConnections = value;
        }

    }

}
