//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.example.schema.s1685_2022;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlID;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * A field within a register
 * 
 * <p>Java class for fieldType complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="fieldType">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}nameGroup"/>
 *         <element name="accessHandles" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence maxOccurs="unbounded">
 *                   <element name="accessHandle" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}slicedAccessHandle"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element name="array" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}dim" maxOccurs="unbounded"/>
 *                   <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}bitStride" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element name="bitOffset" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedIntExpression"/>
 *         <choice>
 *           <element name="fieldDefinitionRef">
 *             <complexType>
 *               <simpleContent>
 *                 <extension base="<http://www.w3.org/2001/XMLSchema>Name">
 *                   <attribute name="typeDefinitions" use="required" type="{http://www.w3.org/2001/XMLSchema}Name" />
 *                 </extension>
 *               </simpleContent>
 *             </complexType>
 *           </element>
 *           <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldDefinitionGroup"/>
 *         </choice>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}parameters" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}vendorExtensions" minOccurs="0"/>
 *       </sequence>
 *       <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "fieldType", propOrder = {
    "name",
    "displayName",
    "shortDescription",
    "description",
    "accessHandles",
    "array",
    "bitOffset",
    "fieldDefinitionRef",
    "typeIdentifier",
    "bitWidth",
    "_volatile",
    "resets",
    "aliasOf",
    "fieldAccessPolicies",
    "enumeratedValues",
    "parameters",
    "vendorExtensions"
})
public class FieldType {

    /**
     * Unique name
     * 
     */
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String name;
    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.
     * 
     */
    protected String displayName;
    /**
     * Brief description suitable for titles, software comments and pop-up windows. Being a SystemVerilog expression the text can be constructed using parameters, e.g, by concatentation or $sformatf().
     * 
     */
    protected String shortDescription;
    /**
     * Full description string, typically for documentation
     * 
     */
    protected String description;
    protected FieldType.AccessHandles accessHandles;
    protected FieldType.Array array;
    /**
     * Offset of this field's bit 0 from bit 0 of the register.
     * 
     */
    @XmlElement(required = true)
    protected UnsignedIntExpression bitOffset;
    protected FieldType.FieldDefinitionRef fieldDefinitionRef;
    /**
     * Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.
     * 
     */
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String typeIdentifier;
    /**
     * Width of the field in bits.
     * 
     */
    protected UnsignedPositiveIntExpression bitWidth;
    /**
     * Indicates whether the data is volatile. The presumed value is 'false' if not present.
     * 
     */
    @XmlElement(name = "volatile", defaultValue = "false")
    protected Boolean _volatile;
    protected FieldType.Resets resets;
    protected FieldType.AliasOf aliasOf;
    protected FieldType.FieldAccessPolicies fieldAccessPolicies;
    /**
     * Enumerates specific values that can be assigned to the bit field.
     * 
     */
    protected EnumeratedValues enumeratedValues;
    /**
     * A collection of parameters and associated value assertions.
     * 
     */
    protected Parameters parameters;
    /**
     * Container for vendor specific extensions.
     * 
     */
    protected VendorExtensions vendorExtensions;
    /**
     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
     * 
     */
    @XmlAttribute(name = "id", namespace = "http://www.w3.org/XML/1998/namespace")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected String id;

    /**
     * Unique name
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getName()
     */
    public void setName(String value) {
        this.name = value;
    }

    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Sets the value of the displayName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDisplayName()
     */
    public void setDisplayName(String value) {
        this.displayName = value;
    }

    /**
     * Brief description suitable for titles, software comments and pop-up windows. Being a SystemVerilog expression the text can be constructed using parameters, e.g, by concatentation or $sformatf().
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getShortDescription() {
        return shortDescription;
    }

    /**
     * Sets the value of the shortDescription property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getShortDescription()
     */
    public void setShortDescription(String value) {
        this.shortDescription = value;
    }

    /**
     * Full description string, typically for documentation
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDescription()
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * Gets the value of the accessHandles property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.AccessHandles }
     *     
     */
    public FieldType.AccessHandles getAccessHandles() {
        return accessHandles;
    }

    /**
     * Sets the value of the accessHandles property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.AccessHandles }
     *     
     */
    public void setAccessHandles(FieldType.AccessHandles value) {
        this.accessHandles = value;
    }

    /**
     * Gets the value of the array property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.Array }
     *     
     */
    public FieldType.Array getArray() {
        return array;
    }

    /**
     * Sets the value of the array property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.Array }
     *     
     */
    public void setArray(FieldType.Array value) {
        this.array = value;
    }

    /**
     * Offset of this field's bit 0 from bit 0 of the register.
     * 
     * @return
     *     possible object is
     *     {@link UnsignedIntExpression }
     *     
     */
    public UnsignedIntExpression getBitOffset() {
        return bitOffset;
    }

    /**
     * Sets the value of the bitOffset property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedIntExpression }
     *     
     * @see #getBitOffset()
     */
    public void setBitOffset(UnsignedIntExpression value) {
        this.bitOffset = value;
    }

    /**
     * Gets the value of the fieldDefinitionRef property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.FieldDefinitionRef }
     *     
     */
    public FieldType.FieldDefinitionRef getFieldDefinitionRef() {
        return fieldDefinitionRef;
    }

    /**
     * Sets the value of the fieldDefinitionRef property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.FieldDefinitionRef }
     *     
     */
    public void setFieldDefinitionRef(FieldType.FieldDefinitionRef value) {
        this.fieldDefinitionRef = value;
    }

    /**
     * Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getTypeIdentifier() {
        return typeIdentifier;
    }

    /**
     * Sets the value of the typeIdentifier property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getTypeIdentifier()
     */
    public void setTypeIdentifier(String value) {
        this.typeIdentifier = value;
    }

    /**
     * Width of the field in bits.
     * 
     * @return
     *     possible object is
     *     {@link UnsignedPositiveIntExpression }
     *     
     */
    public UnsignedPositiveIntExpression getBitWidth() {
        return bitWidth;
    }

    /**
     * Sets the value of the bitWidth property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnsignedPositiveIntExpression }
     *     
     * @see #getBitWidth()
     */
    public void setBitWidth(UnsignedPositiveIntExpression value) {
        this.bitWidth = value;
    }

    /**
     * Indicates whether the data is volatile. The presumed value is 'false' if not present.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isVolatile() {
        return _volatile;
    }

    /**
     * Sets the value of the volatile property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     * @see #isVolatile()
     */
    public void setVolatile(Boolean value) {
        this._volatile = value;
    }

    /**
     * Gets the value of the resets property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.Resets }
     *     
     */
    public FieldType.Resets getResets() {
        return resets;
    }

    /**
     * Sets the value of the resets property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.Resets }
     *     
     */
    public void setResets(FieldType.Resets value) {
        this.resets = value;
    }

    /**
     * Gets the value of the aliasOf property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.AliasOf }
     *     
     */
    public FieldType.AliasOf getAliasOf() {
        return aliasOf;
    }

    /**
     * Sets the value of the aliasOf property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.AliasOf }
     *     
     */
    public void setAliasOf(FieldType.AliasOf value) {
        this.aliasOf = value;
    }

    /**
     * Gets the value of the fieldAccessPolicies property.
     * 
     * @return
     *     possible object is
     *     {@link FieldType.FieldAccessPolicies }
     *     
     */
    public FieldType.FieldAccessPolicies getFieldAccessPolicies() {
        return fieldAccessPolicies;
    }

    /**
     * Sets the value of the fieldAccessPolicies property.
     * 
     * @param value
     *     allowed object is
     *     {@link FieldType.FieldAccessPolicies }
     *     
     */
    public void setFieldAccessPolicies(FieldType.FieldAccessPolicies value) {
        this.fieldAccessPolicies = value;
    }

    /**
     * Enumerates specific values that can be assigned to the bit field.
     * 
     * @return
     *     possible object is
     *     {@link EnumeratedValues }
     *     
     */
    public EnumeratedValues getEnumeratedValues() {
        return enumeratedValues;
    }

    /**
     * Sets the value of the enumeratedValues property.
     * 
     * @param value
     *     allowed object is
     *     {@link EnumeratedValues }
     *     
     * @see #getEnumeratedValues()
     */
    public void setEnumeratedValues(EnumeratedValues value) {
        this.enumeratedValues = value;
    }

    /**
     * A collection of parameters and associated value assertions.
     * 
     * @return
     *     possible object is
     *     {@link Parameters }
     *     
     */
    public Parameters getParameters() {
        return parameters;
    }

    /**
     * Sets the value of the parameters property.
     * 
     * @param value
     *     allowed object is
     *     {@link Parameters }
     *     
     * @see #getParameters()
     */
    public void setParameters(Parameters value) {
        this.parameters = value;
    }

    /**
     * Container for vendor specific extensions.
     * 
     * @return
     *     possible object is
     *     {@link VendorExtensions }
     *     
     */
    public VendorExtensions getVendorExtensions() {
        return vendorExtensions;
    }

    /**
     * Sets the value of the vendorExtensions property.
     * 
     * @param value
     *     allowed object is
     *     {@link VendorExtensions }
     *     
     * @see #getVendorExtensions()
     */
    public void setVendorExtensions(VendorExtensions value) {
        this.vendorExtensions = value;
    }

    /**
     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getId()
     */
    public void setId(String value) {
        this.id = value;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence maxOccurs="unbounded">
     *         <element name="accessHandle" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}slicedAccessHandle"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "accessHandle"
    })
    public static class AccessHandles {

        @XmlElement(required = true)
        protected List<SlicedAccessHandle> accessHandle;

        /**
         * Gets the value of the accessHandle property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the accessHandle property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getAccessHandle().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link SlicedAccessHandle }
         * </p>
         * 
         * 
         * @return
         *     The value of the accessHandle property.
         */
        public List<SlicedAccessHandle> getAccessHandle() {
            if (accessHandle == null) {
                accessHandle = new ArrayList<>();
            }
            return this.accessHandle;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldReferenceGroup"/>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "addressSpaceRef",
        "memoryMapRef",
        "memoryRemapRef",
        "bankRef",
        "addressBlockRef",
        "registerFileRef",
        "registerRef",
        "alternateRegisterRef",
        "fieldRef"
    })
    public static class AliasOf {

        protected org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef addressSpaceRef;
        protected org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef memoryMapRef;
        protected MemoryRemapRef memoryRemapRef;
        protected List<BankRef> bankRef;
        protected AddressBlockRef addressBlockRef;
        protected List<RegisterFileRef> registerFileRef;
        protected RegisterRef registerRef;
        protected AlternateRegisterRef alternateRegisterRef;
        @XmlElement(required = true)
        protected FieldRef fieldRef;

        /**
         * Gets the value of the addressSpaceRef property.
         * 
         * @return
         *     possible object is
         *     {@link org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef }
         *     
         */
        public org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef getAddressSpaceRef() {
            return addressSpaceRef;
        }

        /**
         * Sets the value of the addressSpaceRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef }
         *     
         */
        public void setAddressSpaceRef(org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef value) {
            this.addressSpaceRef = value;
        }

        /**
         * Gets the value of the memoryMapRef property.
         * 
         * @return
         *     possible object is
         *     {@link org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef }
         *     
         */
        public org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef getMemoryMapRef() {
            return memoryMapRef;
        }

        /**
         * Sets the value of the memoryMapRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef }
         *     
         */
        public void setMemoryMapRef(org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef value) {
            this.memoryMapRef = value;
        }

        /**
         * Gets the value of the memoryRemapRef property.
         * 
         * @return
         *     possible object is
         *     {@link MemoryRemapRef }
         *     
         */
        public MemoryRemapRef getMemoryRemapRef() {
            return memoryRemapRef;
        }

        /**
         * Sets the value of the memoryRemapRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link MemoryRemapRef }
         *     
         */
        public void setMemoryRemapRef(MemoryRemapRef value) {
            this.memoryRemapRef = value;
        }

        /**
         * Gets the value of the bankRef property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the bankRef property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getBankRef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link BankRef }
         * </p>
         * 
         * 
         * @return
         *     The value of the bankRef property.
         */
        public List<BankRef> getBankRef() {
            if (bankRef == null) {
                bankRef = new ArrayList<>();
            }
            return this.bankRef;
        }

        /**
         * Gets the value of the addressBlockRef property.
         * 
         * @return
         *     possible object is
         *     {@link AddressBlockRef }
         *     
         */
        public AddressBlockRef getAddressBlockRef() {
            return addressBlockRef;
        }

        /**
         * Sets the value of the addressBlockRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link AddressBlockRef }
         *     
         */
        public void setAddressBlockRef(AddressBlockRef value) {
            this.addressBlockRef = value;
        }

        /**
         * Gets the value of the registerFileRef property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the registerFileRef property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getRegisterFileRef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link RegisterFileRef }
         * </p>
         * 
         * 
         * @return
         *     The value of the registerFileRef property.
         */
        public List<RegisterFileRef> getRegisterFileRef() {
            if (registerFileRef == null) {
                registerFileRef = new ArrayList<>();
            }
            return this.registerFileRef;
        }

        /**
         * Gets the value of the registerRef property.
         * 
         * @return
         *     possible object is
         *     {@link RegisterRef }
         *     
         */
        public RegisterRef getRegisterRef() {
            return registerRef;
        }

        /**
         * Sets the value of the registerRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link RegisterRef }
         *     
         */
        public void setRegisterRef(RegisterRef value) {
            this.registerRef = value;
        }

        /**
         * Gets the value of the alternateRegisterRef property.
         * 
         * @return
         *     possible object is
         *     {@link AlternateRegisterRef }
         *     
         */
        public AlternateRegisterRef getAlternateRegisterRef() {
            return alternateRegisterRef;
        }

        /**
         * Sets the value of the alternateRegisterRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link AlternateRegisterRef }
         *     
         */
        public void setAlternateRegisterRef(AlternateRegisterRef value) {
            this.alternateRegisterRef = value;
        }

        /**
         * Gets the value of the fieldRef property.
         * 
         * @return
         *     possible object is
         *     {@link FieldRef }
         *     
         */
        public FieldRef getFieldRef() {
            return fieldRef;
        }

        /**
         * Sets the value of the fieldRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link FieldRef }
         *     
         */
        public void setFieldRef(FieldRef value) {
            this.fieldRef = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}dim" maxOccurs="unbounded"/>
     *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}bitStride" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "dim",
        "bitStride"
    })
    public static class Array {

        /**
         * Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
         * 
         */
        @XmlElement(required = true)
        protected List<Dim> dim;
        protected BitStride bitStride;

        /**
         * Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
         * 
         * Gets the value of the dim property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the dim property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getDim().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Dim }
         * </p>
         * 
         * 
         * @return
         *     The value of the dim property.
         */
        public List<Dim> getDim() {
            if (dim == null) {
                dim = new ArrayList<>();
            }
            return this.dim;
        }

        /**
         * Gets the value of the bitStride property.
         * 
         * @return
         *     possible object is
         *     {@link BitStride }
         *     
         */
        public BitStride getBitStride() {
            return bitStride;
        }

        /**
         * Sets the value of the bitStride property.
         * 
         * @param value
         *     allowed object is
         *     {@link BitStride }
         *     
         */
        public void setBitStride(BitStride value) {
            this.bitStride = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <extension base="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldAccessPropertiesType">
     *       <sequence>
     *         <element name="fieldAccessPolicy" maxOccurs="unbounded">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <sequence>
     *                   <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}modeRef" maxOccurs="unbounded" minOccurs="0"/>
     *                   <choice>
     *                     <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldAccessPolicyDefinitionRef" minOccurs="0"/>
     *                     <sequence>
     *                       <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}access" minOccurs="0"/>
     *                       <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}modifiedWriteValue" minOccurs="0"/>
     *                       <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}writeValueConstraint" minOccurs="0"/>
     *                       <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}readAction" minOccurs="0"/>
     *                       <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}readResponse" minOccurs="0"/>
     *                     </sequence>
     *                   </choice>
     *                   <element name="broadcasts" minOccurs="0">
     *                     <complexType>
     *                       <complexContent>
     *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                           <sequence>
     *                             <element name="broadcastTo" maxOccurs="unbounded">
     *                               <complexType>
     *                                 <complexContent>
     *                                   <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                                     <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldReferenceGroup"/>
     *                                     <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
     *                                   </restriction>
     *                                 </complexContent>
     *                               </complexType>
     *                             </element>
     *                           </sequence>
     *                         </restriction>
     *                       </complexContent>
     *                     </complexType>
     *                   </element>
     *                   <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}accessRestrictions" minOccurs="0"/>
     *                   <element name="testable" minOccurs="0">
     *                     <complexType>
     *                       <simpleContent>
     *                         <extension base="<http://www.w3.org/2001/XMLSchema>boolean">
     *                           <attribute name="testConstraint" default="unconstrained">
     *                             <simpleType>
     *                               <restriction base="{http://www.w3.org/2001/XMLSchema}string">
     *                                 <enumeration value="unconstrained"/>
     *                                 <enumeration value="restore"/>
     *                                 <enumeration value="writeAsRead"/>
     *                                 <enumeration value="readOnly"/>
     *                               </restriction>
     *                             </simpleType>
     *                           </attribute>
     *                         </extension>
     *                       </simpleContent>
     *                     </complexType>
     *                   </element>
     *                   <element name="reserved" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedBitExpression" minOccurs="0"/>
     *                   <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}vendorExtensions" minOccurs="0"/>
     *                 </sequence>
     *                 <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </extension>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "fieldAccessPolicy"
    })
    public static class FieldAccessPolicies
        extends FieldAccessPropertiesType
    {

        @XmlElement(required = true)
        protected List<FieldType.FieldAccessPolicies.FieldAccessPolicy> fieldAccessPolicy;

        /**
         * Gets the value of the fieldAccessPolicy property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fieldAccessPolicy property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getFieldAccessPolicy().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link FieldType.FieldAccessPolicies.FieldAccessPolicy }
         * </p>
         * 
         * 
         * @return
         *     The value of the fieldAccessPolicy property.
         */
        public List<FieldType.FieldAccessPolicies.FieldAccessPolicy> getFieldAccessPolicy() {
            if (fieldAccessPolicy == null) {
                fieldAccessPolicy = new ArrayList<>();
            }
            return this.fieldAccessPolicy;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <sequence>
         *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}modeRef" maxOccurs="unbounded" minOccurs="0"/>
         *         <choice>
         *           <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldAccessPolicyDefinitionRef" minOccurs="0"/>
         *           <sequence>
         *             <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}access" minOccurs="0"/>
         *             <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}modifiedWriteValue" minOccurs="0"/>
         *             <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}writeValueConstraint" minOccurs="0"/>
         *             <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}readAction" minOccurs="0"/>
         *             <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}readResponse" minOccurs="0"/>
         *           </sequence>
         *         </choice>
         *         <element name="broadcasts" minOccurs="0">
         *           <complexType>
         *             <complexContent>
         *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                 <sequence>
         *                   <element name="broadcastTo" maxOccurs="unbounded">
         *                     <complexType>
         *                       <complexContent>
         *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                           <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldReferenceGroup"/>
         *                           <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
         *                         </restriction>
         *                       </complexContent>
         *                     </complexType>
         *                   </element>
         *                 </sequence>
         *               </restriction>
         *             </complexContent>
         *           </complexType>
         *         </element>
         *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}accessRestrictions" minOccurs="0"/>
         *         <element name="testable" minOccurs="0">
         *           <complexType>
         *             <simpleContent>
         *               <extension base="<http://www.w3.org/2001/XMLSchema>boolean">
         *                 <attribute name="testConstraint" default="unconstrained">
         *                   <simpleType>
         *                     <restriction base="{http://www.w3.org/2001/XMLSchema}string">
         *                       <enumeration value="unconstrained"/>
         *                       <enumeration value="restore"/>
         *                       <enumeration value="writeAsRead"/>
         *                       <enumeration value="readOnly"/>
         *                     </restriction>
         *                   </simpleType>
         *                 </attribute>
         *               </extension>
         *             </simpleContent>
         *           </complexType>
         *         </element>
         *         <element name="reserved" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}unsignedBitExpression" minOccurs="0"/>
         *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}vendorExtensions" minOccurs="0"/>
         *       </sequence>
         *       <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "modeRef",
            "fieldAccessPolicyDefinitionRef",
            "access",
            "modifiedWriteValue",
            "writeValueConstraint",
            "readAction",
            "readResponse",
            "broadcasts",
            "accessRestrictions",
            "testable",
            "reserved",
            "vendorExtensions"
        })
        public static class FieldAccessPolicy {

            /**
             * A reference to a mode.
             * 
             */
            protected List<ModeRef> modeRef;
            /**
             * Indicates the accessibility of the data in the field.
             * 
             */
            protected FieldAccessPolicyDefinitionRef fieldAccessPolicyDefinitionRef;
            @XmlSchemaType(name = "token")
            protected AccessType access;
            /**
             * If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.
             * 
             */
            protected ModifiedWriteValue modifiedWriteValue;
            /**
             * The legal values that may be written to a field. If not specified the legal values are not specified.
             * 
             */
            protected WriteValueConstraintType writeValueConstraint;
            /**
             * A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.
             * 
             */
            protected ReadAction readAction;
            protected UnsignedBitVectorExpression readResponse;
            protected FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts broadcasts;
            /**
             * Access restrictions
             * 
             */
            protected AccessRestrictionsType accessRestrictions;
            /**
             * Can the field be tested with an automated register test routine. The presumed value is true if not specified.
             * 
             */
            protected FieldType.FieldAccessPolicies.FieldAccessPolicy.Testable testable;
            /**
             * Indicates that the field should be documented as reserved. The presumed value is '0' if not present.
             * 
             */
            @XmlElement(defaultValue = "0")
            protected UnsignedBitExpression reserved;
            /**
             * Container for vendor specific extensions.
             * 
             */
            protected VendorExtensions vendorExtensions;
            /**
             * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
             * 
             */
            @XmlAttribute(name = "id", namespace = "http://www.w3.org/XML/1998/namespace")
            @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
            @XmlID
            @XmlSchemaType(name = "ID")
            protected String id;

            /**
             * A reference to a mode.
             * 
             * Gets the value of the modeRef property.
             * 
             * <p>This accessor method returns a reference to the live list,
             * not a snapshot. Therefore any modification you make to the
             * returned list will be present inside the JAXB object.
             * This is why there is not a <CODE>set</CODE> method for the modeRef property.</p>
             * 
             * <p>
             * For example, to add a new item, do as follows:
             * </p>
             * <pre>
             * getModeRef().add(newItem);
             * </pre>
             * 
             * 
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link ModeRef }
             * </p>
             * 
             * 
             * @return
             *     The value of the modeRef property.
             */
            public List<ModeRef> getModeRef() {
                if (modeRef == null) {
                    modeRef = new ArrayList<>();
                }
                return this.modeRef;
            }

            /**
             * Indicates the accessibility of the data in the field.
             * 
             * @return
             *     possible object is
             *     {@link FieldAccessPolicyDefinitionRef }
             *     
             */
            public FieldAccessPolicyDefinitionRef getFieldAccessPolicyDefinitionRef() {
                return fieldAccessPolicyDefinitionRef;
            }

            /**
             * Sets the value of the fieldAccessPolicyDefinitionRef property.
             * 
             * @param value
             *     allowed object is
             *     {@link FieldAccessPolicyDefinitionRef }
             *     
             * @see #getFieldAccessPolicyDefinitionRef()
             */
            public void setFieldAccessPolicyDefinitionRef(FieldAccessPolicyDefinitionRef value) {
                this.fieldAccessPolicyDefinitionRef = value;
            }

            /**
             * Gets the value of the access property.
             * 
             * @return
             *     possible object is
             *     {@link AccessType }
             *     
             */
            public AccessType getAccess() {
                return access;
            }

            /**
             * Sets the value of the access property.
             * 
             * @param value
             *     allowed object is
             *     {@link AccessType }
             *     
             */
            public void setAccess(AccessType value) {
                this.access = value;
            }

            /**
             * If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.
             * 
             * @return
             *     possible object is
             *     {@link ModifiedWriteValue }
             *     
             */
            public ModifiedWriteValue getModifiedWriteValue() {
                return modifiedWriteValue;
            }

            /**
             * Sets the value of the modifiedWriteValue property.
             * 
             * @param value
             *     allowed object is
             *     {@link ModifiedWriteValue }
             *     
             * @see #getModifiedWriteValue()
             */
            public void setModifiedWriteValue(ModifiedWriteValue value) {
                this.modifiedWriteValue = value;
            }

            /**
             * The legal values that may be written to a field. If not specified the legal values are not specified.
             * 
             * @return
             *     possible object is
             *     {@link WriteValueConstraintType }
             *     
             */
            public WriteValueConstraintType getWriteValueConstraint() {
                return writeValueConstraint;
            }

            /**
             * Sets the value of the writeValueConstraint property.
             * 
             * @param value
             *     allowed object is
             *     {@link WriteValueConstraintType }
             *     
             * @see #getWriteValueConstraint()
             */
            public void setWriteValueConstraint(WriteValueConstraintType value) {
                this.writeValueConstraint = value;
            }

            /**
             * A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.
             * 
             * @return
             *     possible object is
             *     {@link ReadAction }
             *     
             */
            public ReadAction getReadAction() {
                return readAction;
            }

            /**
             * Sets the value of the readAction property.
             * 
             * @param value
             *     allowed object is
             *     {@link ReadAction }
             *     
             * @see #getReadAction()
             */
            public void setReadAction(ReadAction value) {
                this.readAction = value;
            }

            /**
             * Gets the value of the readResponse property.
             * 
             * @return
             *     possible object is
             *     {@link UnsignedBitVectorExpression }
             *     
             */
            public UnsignedBitVectorExpression getReadResponse() {
                return readResponse;
            }

            /**
             * Sets the value of the readResponse property.
             * 
             * @param value
             *     allowed object is
             *     {@link UnsignedBitVectorExpression }
             *     
             */
            public void setReadResponse(UnsignedBitVectorExpression value) {
                this.readResponse = value;
            }

            /**
             * Gets the value of the broadcasts property.
             * 
             * @return
             *     possible object is
             *     {@link FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts }
             *     
             */
            public FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts getBroadcasts() {
                return broadcasts;
            }

            /**
             * Sets the value of the broadcasts property.
             * 
             * @param value
             *     allowed object is
             *     {@link FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts }
             *     
             */
            public void setBroadcasts(FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts value) {
                this.broadcasts = value;
            }

            /**
             * Access restrictions
             * 
             * @return
             *     possible object is
             *     {@link AccessRestrictionsType }
             *     
             */
            public AccessRestrictionsType getAccessRestrictions() {
                return accessRestrictions;
            }

            /**
             * Sets the value of the accessRestrictions property.
             * 
             * @param value
             *     allowed object is
             *     {@link AccessRestrictionsType }
             *     
             * @see #getAccessRestrictions()
             */
            public void setAccessRestrictions(AccessRestrictionsType value) {
                this.accessRestrictions = value;
            }

            /**
             * Can the field be tested with an automated register test routine. The presumed value is true if not specified.
             * 
             * @return
             *     possible object is
             *     {@link FieldType.FieldAccessPolicies.FieldAccessPolicy.Testable }
             *     
             */
            public FieldType.FieldAccessPolicies.FieldAccessPolicy.Testable getTestable() {
                return testable;
            }

            /**
             * Sets the value of the testable property.
             * 
             * @param value
             *     allowed object is
             *     {@link FieldType.FieldAccessPolicies.FieldAccessPolicy.Testable }
             *     
             * @see #getTestable()
             */
            public void setTestable(FieldType.FieldAccessPolicies.FieldAccessPolicy.Testable value) {
                this.testable = value;
            }

            /**
             * Indicates that the field should be documented as reserved. The presumed value is '0' if not present.
             * 
             * @return
             *     possible object is
             *     {@link UnsignedBitExpression }
             *     
             */
            public UnsignedBitExpression getReserved() {
                return reserved;
            }

            /**
             * Sets the value of the reserved property.
             * 
             * @param value
             *     allowed object is
             *     {@link UnsignedBitExpression }
             *     
             * @see #getReserved()
             */
            public void setReserved(UnsignedBitExpression value) {
                this.reserved = value;
            }

            /**
             * Container for vendor specific extensions.
             * 
             * @return
             *     possible object is
             *     {@link VendorExtensions }
             *     
             */
            public VendorExtensions getVendorExtensions() {
                return vendorExtensions;
            }

            /**
             * Sets the value of the vendorExtensions property.
             * 
             * @param value
             *     allowed object is
             *     {@link VendorExtensions }
             *     
             * @see #getVendorExtensions()
             */
            public void setVendorExtensions(VendorExtensions value) {
                this.vendorExtensions = value;
            }

            /**
             * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getId() {
                return id;
            }

            /**
             * Sets the value of the id property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             * @see #getId()
             */
            public void setId(String value) {
                this.id = value;
            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <complexContent>
             *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *       <sequence>
             *         <element name="broadcastTo" maxOccurs="unbounded">
             *           <complexType>
             *             <complexContent>
             *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *                 <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldReferenceGroup"/>
             *                 <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
             *               </restriction>
             *             </complexContent>
             *           </complexType>
             *         </element>
             *       </sequence>
             *     </restriction>
             *   </complexContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "broadcastTo"
            })
            public static class Broadcasts {

                @XmlElement(required = true)
                protected List<FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts.BroadcastTo> broadcastTo;

                /**
                 * Gets the value of the broadcastTo property.
                 * 
                 * <p>This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object.
                 * This is why there is not a <CODE>set</CODE> method for the broadcastTo property.</p>
                 * 
                 * <p>
                 * For example, to add a new item, do as follows:
                 * </p>
                 * <pre>
                 * getBroadcastTo().add(newItem);
                 * </pre>
                 * 
                 * 
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts.BroadcastTo }
                 * </p>
                 * 
                 * 
                 * @return
                 *     The value of the broadcastTo property.
                 */
                public List<FieldType.FieldAccessPolicies.FieldAccessPolicy.Broadcasts.BroadcastTo> getBroadcastTo() {
                    if (broadcastTo == null) {
                        broadcastTo = new ArrayList<>();
                    }
                    return this.broadcastTo;
                }


                /**
                 * <p>Java class for anonymous complex type</p>.
                 * 
                 * <p>The following schema fragment specifies the expected content contained within this class.</p>
                 * 
                 * <pre>{@code
                 * <complexType>
                 *   <complexContent>
                 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
                 *       <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}fieldReferenceGroup"/>
                 *       <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}id.att"/>
                 *     </restriction>
                 *   </complexContent>
                 * </complexType>
                 * }</pre>
                 * 
                 * 
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = {
                    "addressSpaceRef",
                    "memoryMapRef",
                    "memoryRemapRef",
                    "bankRef",
                    "addressBlockRef",
                    "registerFileRef",
                    "registerRef",
                    "alternateRegisterRef",
                    "fieldRef"
                })
                public static class BroadcastTo {

                    protected org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef addressSpaceRef;
                    protected org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef memoryMapRef;
                    protected MemoryRemapRef memoryRemapRef;
                    protected List<BankRef> bankRef;
                    protected AddressBlockRef addressBlockRef;
                    protected List<RegisterFileRef> registerFileRef;
                    protected RegisterRef registerRef;
                    protected AlternateRegisterRef alternateRegisterRef;
                    @XmlElement(required = true)
                    protected FieldRef fieldRef;
                    /**
                     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
                     * 
                     */
                    @XmlAttribute(name = "id", namespace = "http://www.w3.org/XML/1998/namespace")
                    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                    @XmlID
                    @XmlSchemaType(name = "ID")
                    protected String id;

                    /**
                     * Gets the value of the addressSpaceRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef }
                     *     
                     */
                    public org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef getAddressSpaceRef() {
                        return addressSpaceRef;
                    }

                    /**
                     * Sets the value of the addressSpaceRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef }
                     *     
                     */
                    public void setAddressSpaceRef(org.example.schema.s1685_2022.IndirectAddressRef.AddressSpaceRef value) {
                        this.addressSpaceRef = value;
                    }

                    /**
                     * Gets the value of the memoryMapRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef }
                     *     
                     */
                    public org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef getMemoryMapRef() {
                        return memoryMapRef;
                    }

                    /**
                     * Sets the value of the memoryMapRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef }
                     *     
                     */
                    public void setMemoryMapRef(org.example.schema.s1685_2022.IndirectAddressRef.MemoryMapRef value) {
                        this.memoryMapRef = value;
                    }

                    /**
                     * Gets the value of the memoryRemapRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link MemoryRemapRef }
                     *     
                     */
                    public MemoryRemapRef getMemoryRemapRef() {
                        return memoryRemapRef;
                    }

                    /**
                     * Sets the value of the memoryRemapRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link MemoryRemapRef }
                     *     
                     */
                    public void setMemoryRemapRef(MemoryRemapRef value) {
                        this.memoryRemapRef = value;
                    }

                    /**
                     * Gets the value of the bankRef property.
                     * 
                     * <p>This accessor method returns a reference to the live list,
                     * not a snapshot. Therefore any modification you make to the
                     * returned list will be present inside the JAXB object.
                     * This is why there is not a <CODE>set</CODE> method for the bankRef property.</p>
                     * 
                     * <p>
                     * For example, to add a new item, do as follows:
                     * </p>
                     * <pre>
                     * getBankRef().add(newItem);
                     * </pre>
                     * 
                     * 
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link BankRef }
                     * </p>
                     * 
                     * 
                     * @return
                     *     The value of the bankRef property.
                     */
                    public List<BankRef> getBankRef() {
                        if (bankRef == null) {
                            bankRef = new ArrayList<>();
                        }
                        return this.bankRef;
                    }

                    /**
                     * Gets the value of the addressBlockRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link AddressBlockRef }
                     *     
                     */
                    public AddressBlockRef getAddressBlockRef() {
                        return addressBlockRef;
                    }

                    /**
                     * Sets the value of the addressBlockRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link AddressBlockRef }
                     *     
                     */
                    public void setAddressBlockRef(AddressBlockRef value) {
                        this.addressBlockRef = value;
                    }

                    /**
                     * Gets the value of the registerFileRef property.
                     * 
                     * <p>This accessor method returns a reference to the live list,
                     * not a snapshot. Therefore any modification you make to the
                     * returned list will be present inside the JAXB object.
                     * This is why there is not a <CODE>set</CODE> method for the registerFileRef property.</p>
                     * 
                     * <p>
                     * For example, to add a new item, do as follows:
                     * </p>
                     * <pre>
                     * getRegisterFileRef().add(newItem);
                     * </pre>
                     * 
                     * 
                     * <p>
                     * Objects of the following type(s) are allowed in the list
                     * {@link RegisterFileRef }
                     * </p>
                     * 
                     * 
                     * @return
                     *     The value of the registerFileRef property.
                     */
                    public List<RegisterFileRef> getRegisterFileRef() {
                        if (registerFileRef == null) {
                            registerFileRef = new ArrayList<>();
                        }
                        return this.registerFileRef;
                    }

                    /**
                     * Gets the value of the registerRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link RegisterRef }
                     *     
                     */
                    public RegisterRef getRegisterRef() {
                        return registerRef;
                    }

                    /**
                     * Sets the value of the registerRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link RegisterRef }
                     *     
                     */
                    public void setRegisterRef(RegisterRef value) {
                        this.registerRef = value;
                    }

                    /**
                     * Gets the value of the alternateRegisterRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link AlternateRegisterRef }
                     *     
                     */
                    public AlternateRegisterRef getAlternateRegisterRef() {
                        return alternateRegisterRef;
                    }

                    /**
                     * Sets the value of the alternateRegisterRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link AlternateRegisterRef }
                     *     
                     */
                    public void setAlternateRegisterRef(AlternateRegisterRef value) {
                        this.alternateRegisterRef = value;
                    }

                    /**
                     * Gets the value of the fieldRef property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link FieldRef }
                     *     
                     */
                    public FieldRef getFieldRef() {
                        return fieldRef;
                    }

                    /**
                     * Sets the value of the fieldRef property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link FieldRef }
                     *     
                     */
                    public void setFieldRef(FieldRef value) {
                        this.fieldRef = value;
                    }

                    /**
                     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getId() {
                        return id;
                    }

                    /**
                     * Sets the value of the id property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     * @see #getId()
                     */
                    public void setId(String value) {
                        this.id = value;
                    }

                }

            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <simpleContent>
             *     <extension base="<http://www.w3.org/2001/XMLSchema>boolean">
             *       <attribute name="testConstraint" default="unconstrained">
             *         <simpleType>
             *           <restriction base="{http://www.w3.org/2001/XMLSchema}string">
             *             <enumeration value="unconstrained"/>
             *             <enumeration value="restore"/>
             *             <enumeration value="writeAsRead"/>
             *             <enumeration value="readOnly"/>
             *           </restriction>
             *         </simpleType>
             *       </attribute>
             *     </extension>
             *   </simpleContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "value"
            })
            public static class Testable {

                @XmlValue
                protected boolean value;
                /**
                 * Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.
                 * 
                 */
                @XmlAttribute(name = "testConstraint")
                protected String testConstraint;

                /**
                 * Gets the value of the value property.
                 * 
                 */
                public boolean isValue() {
                    return value;
                }

                /**
                 * Sets the value of the value property.
                 * 
                 */
                public void setValue(boolean value) {
                    this.value = value;
                }

                /**
                 * Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getTestConstraint() {
                    if (testConstraint == null) {
                        return "unconstrained";
                    } else {
                        return testConstraint;
                    }
                }

                /**
                 * Sets the value of the testConstraint property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getTestConstraint()
                 */
                public void setTestConstraint(String value) {
                    this.testConstraint = value;
                }

            }

        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.w3.org/2001/XMLSchema>Name">
     *       <attribute name="typeDefinitions" use="required" type="{http://www.w3.org/2001/XMLSchema}Name" />
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class FieldDefinitionRef {

        @XmlValue
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String value;
        @XmlAttribute(name = "typeDefinitions", required = true)
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String typeDefinitions;

        /**
         * Gets the value of the value property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setValue(String value) {
            this.value = value;
        }

        /**
         * Gets the value of the typeDefinitions property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getTypeDefinitions() {
            return typeDefinitions;
        }

        /**
         * Sets the value of the typeDefinitions property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setTypeDefinitions(String value) {
            this.typeDefinitions = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2022}reset" maxOccurs="unbounded"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "reset"
    })
    public static class Resets {

        /**
         * BitField reset value
         * 
         */
        @XmlElement(required = true)
        protected List<Reset> reset;

        /**
         * BitField reset value
         * 
         * Gets the value of the reset property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the reset property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getReset().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Reset }
         * </p>
         * 
         * 
         * @return
         *     The value of the reset property.
         */
        public List<Reset> getReset() {
            if (reset == null) {
                reset = new ArrayList<>();
            }
            return this.reset;
        }

    }

}
