//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.example.schema.s1685_2009;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.namespace.QName;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAnyAttribute;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlID;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.XmlValue;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * Type definition for a busInterface in a component
 * 
 * <p>Java class for busInterfaceType complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="busInterfaceType">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}nameGroup"/>
 *         <element name="busType" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}libraryRefType"/>
 *         <element name="abstractionType" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}libraryRefType" minOccurs="0"/>
 *         <group ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}interfaceMode"/>
 *         <element name="connectionRequired" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/>
 *         <element name="portMaps" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="portMap" maxOccurs="unbounded">
 *                     <complexType>
 *                       <complexContent>
 *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           <sequence>
 *                             <element name="logicalPort">
 *                               <complexType>
 *                                 <complexContent>
 *                                   <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                     <sequence>
 *                                       <element name="name" type="{http://www.w3.org/2001/XMLSchema}Name"/>
 *                                       <element name="vector" minOccurs="0">
 *                                         <complexType>
 *                                           <complexContent>
 *                                             <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                               <sequence>
 *                                                 <element name="left">
 *                                                   <complexType>
 *                                                     <simpleContent>
 *                                                       <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
 *                                                         <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
 *                                                       </extension>
 *                                                     </simpleContent>
 *                                                   </complexType>
 *                                                 </element>
 *                                                 <element name="right">
 *                                                   <complexType>
 *                                                     <simpleContent>
 *                                                       <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
 *                                                         <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
 *                                                       </extension>
 *                                                     </simpleContent>
 *                                                   </complexType>
 *                                                 </element>
 *                                               </sequence>
 *                                             </restriction>
 *                                           </complexContent>
 *                                         </complexType>
 *                                       </element>
 *                                     </sequence>
 *                                   </restriction>
 *                                 </complexContent>
 *                               </complexType>
 *                             </element>
 *                             <element name="physicalPort">
 *                               <complexType>
 *                                 <complexContent>
 *                                   <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                                     <sequence>
 *                                       <element name="name" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portName"/>
 *                                       <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vector" minOccurs="0"/>
 *                                     </sequence>
 *                                   </restriction>
 *                                 </complexContent>
 *                               </complexType>
 *                             </element>
 *                           </sequence>
 *                         </restriction>
 *                       </complexContent>
 *                     </complexType>
 *                   </element>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}bitsInLau" minOccurs="0"/>
 *         <element name="bitSteering" minOccurs="0">
 *           <complexType>
 *             <simpleContent>
 *               <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>bitSteeringType">
 *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}string.prompt.att"/>
 *               </extension>
 *             </simpleContent>
 *           </complexType>
 *         </element>
 *         <element name="endianness" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}endianessType" minOccurs="0"/>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}parameters" minOccurs="0"/>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
 *       </sequence>
 *       <anyAttribute processContents='lax'/>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "busInterfaceType", propOrder = {
    "name",
    "displayName",
    "description",
    "busType",
    "abstractionType",
    "master",
    "slave",
    "system",
    "mirroredSlave",
    "mirroredMaster",
    "mirroredSystem",
    "monitor",
    "connectionRequired",
    "portMaps",
    "bitsInLau",
    "bitSteering",
    "endianness",
    "parameters",
    "vendorExtensions"
})
public class BusInterfaceType {

    /**
     * Unique name
     * 
     */
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "Name")
    protected String name;
    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
     * 
     */
    protected String displayName;
    /**
     * Full description string, typically for documentation
     * 
     */
    protected String description;
    /**
     * The bus type of this interface. Refers to bus definition using vendor, library, name, version attributes.
     * 
     */
    @XmlElement(required = true)
    protected LibraryRefType busType;
    /**
     * The abstraction type/level of this interface. Refers to abstraction definition using vendor, library, name, version attributes. Bus definition can be found through a reference in this file.
     * 
     */
    protected LibraryRefType abstractionType;
    /**
     * If this element is present, the bus interface can serve as a master.  This element encapsulates additional information related to its role as master.
     * 
     */
    protected BusInterfaceType.Master master;
    /**
     * If this element is present, the bus interface can serve as a slave.
     * 
     */
    protected BusInterfaceType.Slave slave;
    /**
     * If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus.
     * 
     */
    protected BusInterfaceType.System system;
    /**
     * If this element is present, the bus interface represents a mirrored slave interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
     * 
     */
    protected BusInterfaceType.MirroredSlave mirroredSlave;
    /**
     * If this element is present, the bus interface represents a mirrored master interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
     * 
     */
    protected BusInterfaceType.MirroredMaster mirroredMaster;
    /**
     * If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
     * 
     */
    protected BusInterfaceType.MirroredSystem mirroredSystem;
    /**
     * Indicates that this is a (passive) monitor interface. All of the ports in the interface must be inputs. The type of interface to be monitored is specified with the required interfaceType attribute. The spirit:group element must be specified if monitoring a system interface.
     * 
     */
    protected BusInterfaceType.Monitor monitor;
    /**
     * Indicates whether a connection to this interface is required for proper component functionality.
     * 
     */
    @XmlElement(defaultValue = "false")
    protected Boolean connectionRequired;
    /**
     * Listing of maps between component ports and bus ports.
     * 
     */
    protected BusInterfaceType.PortMaps portMaps;
    /**
     * The number of bits in the least addressable unit. The default is byte addressable (8 bits).
     * 
     */
    @XmlSchemaType(name = "positiveInteger")
    protected BigInteger bitsInLau;
    /**
     * Indicates whether bit steering should be used to map this interface onto a bus of different data width.
     * 
     * Values are "on", "off" (defaults to "off").
     * 
     */
    @XmlElement(defaultValue = "off")
    protected BusInterfaceType.BitSteering bitSteering;
    /**
     * 'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.
     * 
     */
    @XmlSchemaType(name = "string")
    protected EndianessType endianness;
    /**
     * A collection of parameters.
     * 
     */
    protected Parameters parameters;
    /**
     * Container for vendor specific extensions.
     * 
     */
    protected VendorExtensions vendorExtensions;
    @XmlAnyAttribute
    private Map<QName, String> otherAttributes = new HashMap<>();

    /**
     * Unique name
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getName()
     */
    public void setName(String value) {
        this.name = value;
    }

    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the spirit:name.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Sets the value of the displayName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDisplayName()
     */
    public void setDisplayName(String value) {
        this.displayName = value;
    }

    /**
     * Full description string, typically for documentation
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDescription()
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * The bus type of this interface. Refers to bus definition using vendor, library, name, version attributes.
     * 
     * @return
     *     possible object is
     *     {@link LibraryRefType }
     *     
     */
    public LibraryRefType getBusType() {
        return busType;
    }

    /**
     * Sets the value of the busType property.
     * 
     * @param value
     *     allowed object is
     *     {@link LibraryRefType }
     *     
     * @see #getBusType()
     */
    public void setBusType(LibraryRefType value) {
        this.busType = value;
    }

    /**
     * The abstraction type/level of this interface. Refers to abstraction definition using vendor, library, name, version attributes. Bus definition can be found through a reference in this file.
     * 
     * @return
     *     possible object is
     *     {@link LibraryRefType }
     *     
     */
    public LibraryRefType getAbstractionType() {
        return abstractionType;
    }

    /**
     * Sets the value of the abstractionType property.
     * 
     * @param value
     *     allowed object is
     *     {@link LibraryRefType }
     *     
     * @see #getAbstractionType()
     */
    public void setAbstractionType(LibraryRefType value) {
        this.abstractionType = value;
    }

    /**
     * If this element is present, the bus interface can serve as a master.  This element encapsulates additional information related to its role as master.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.Master }
     *     
     */
    public BusInterfaceType.Master getMaster() {
        return master;
    }

    /**
     * Sets the value of the master property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.Master }
     *     
     * @see #getMaster()
     */
    public void setMaster(BusInterfaceType.Master value) {
        this.master = value;
    }

    /**
     * If this element is present, the bus interface can serve as a slave.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.Slave }
     *     
     */
    public BusInterfaceType.Slave getSlave() {
        return slave;
    }

    /**
     * Sets the value of the slave property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.Slave }
     *     
     * @see #getSlave()
     */
    public void setSlave(BusInterfaceType.Slave value) {
        this.slave = value;
    }

    /**
     * If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.System }
     *     
     */
    public BusInterfaceType.System getSystem() {
        return system;
    }

    /**
     * Sets the value of the system property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.System }
     *     
     * @see #getSystem()
     */
    public void setSystem(BusInterfaceType.System value) {
        this.system = value;
    }

    /**
     * If this element is present, the bus interface represents a mirrored slave interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.MirroredSlave }
     *     
     */
    public BusInterfaceType.MirroredSlave getMirroredSlave() {
        return mirroredSlave;
    }

    /**
     * Sets the value of the mirroredSlave property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.MirroredSlave }
     *     
     * @see #getMirroredSlave()
     */
    public void setMirroredSlave(BusInterfaceType.MirroredSlave value) {
        this.mirroredSlave = value;
    }

    /**
     * If this element is present, the bus interface represents a mirrored master interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.MirroredMaster }
     *     
     */
    public BusInterfaceType.MirroredMaster getMirroredMaster() {
        return mirroredMaster;
    }

    /**
     * Sets the value of the mirroredMaster property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.MirroredMaster }
     *     
     * @see #getMirroredMaster()
     */
    public void setMirroredMaster(BusInterfaceType.MirroredMaster value) {
        this.mirroredMaster = value;
    }

    /**
     * If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.MirroredSystem }
     *     
     */
    public BusInterfaceType.MirroredSystem getMirroredSystem() {
        return mirroredSystem;
    }

    /**
     * Sets the value of the mirroredSystem property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.MirroredSystem }
     *     
     * @see #getMirroredSystem()
     */
    public void setMirroredSystem(BusInterfaceType.MirroredSystem value) {
        this.mirroredSystem = value;
    }

    /**
     * Indicates that this is a (passive) monitor interface. All of the ports in the interface must be inputs. The type of interface to be monitored is specified with the required interfaceType attribute. The spirit:group element must be specified if monitoring a system interface.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.Monitor }
     *     
     */
    public BusInterfaceType.Monitor getMonitor() {
        return monitor;
    }

    /**
     * Sets the value of the monitor property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.Monitor }
     *     
     * @see #getMonitor()
     */
    public void setMonitor(BusInterfaceType.Monitor value) {
        this.monitor = value;
    }

    /**
     * Indicates whether a connection to this interface is required for proper component functionality.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isConnectionRequired() {
        return connectionRequired;
    }

    /**
     * Sets the value of the connectionRequired property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     * @see #isConnectionRequired()
     */
    public void setConnectionRequired(Boolean value) {
        this.connectionRequired = value;
    }

    /**
     * Listing of maps between component ports and bus ports.
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.PortMaps }
     *     
     */
    public BusInterfaceType.PortMaps getPortMaps() {
        return portMaps;
    }

    /**
     * Sets the value of the portMaps property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.PortMaps }
     *     
     * @see #getPortMaps()
     */
    public void setPortMaps(BusInterfaceType.PortMaps value) {
        this.portMaps = value;
    }

    /**
     * The number of bits in the least addressable unit. The default is byte addressable (8 bits).
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getBitsInLau() {
        return bitsInLau;
    }

    /**
     * Sets the value of the bitsInLau property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     * @see #getBitsInLau()
     */
    public void setBitsInLau(BigInteger value) {
        this.bitsInLau = value;
    }

    /**
     * Indicates whether bit steering should be used to map this interface onto a bus of different data width.
     * 
     * Values are "on", "off" (defaults to "off").
     * 
     * @return
     *     possible object is
     *     {@link BusInterfaceType.BitSteering }
     *     
     */
    public BusInterfaceType.BitSteering getBitSteering() {
        return bitSteering;
    }

    /**
     * Sets the value of the bitSteering property.
     * 
     * @param value
     *     allowed object is
     *     {@link BusInterfaceType.BitSteering }
     *     
     * @see #getBitSteering()
     */
    public void setBitSteering(BusInterfaceType.BitSteering value) {
        this.bitSteering = value;
    }

    /**
     * 'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.
     * 
     * @return
     *     possible object is
     *     {@link EndianessType }
     *     
     */
    public EndianessType getEndianness() {
        return endianness;
    }

    /**
     * Sets the value of the endianness property.
     * 
     * @param value
     *     allowed object is
     *     {@link EndianessType }
     *     
     * @see #getEndianness()
     */
    public void setEndianness(EndianessType value) {
        this.endianness = value;
    }

    /**
     * A collection of parameters.
     * 
     * @return
     *     possible object is
     *     {@link Parameters }
     *     
     */
    public Parameters getParameters() {
        return parameters;
    }

    /**
     * Sets the value of the parameters property.
     * 
     * @param value
     *     allowed object is
     *     {@link Parameters }
     *     
     * @see #getParameters()
     */
    public void setParameters(Parameters value) {
        this.parameters = value;
    }

    /**
     * Container for vendor specific extensions.
     * 
     * @return
     *     possible object is
     *     {@link VendorExtensions }
     *     
     */
    public VendorExtensions getVendorExtensions() {
        return vendorExtensions;
    }

    /**
     * Sets the value of the vendorExtensions property.
     * 
     * @param value
     *     allowed object is
     *     {@link VendorExtensions }
     *     
     * @see #getVendorExtensions()
     */
    public void setVendorExtensions(VendorExtensions value) {
        this.vendorExtensions = value;
    }

    /**
     * Gets a map that contains attributes that aren't bound to any typed property on this class.
     * 
     * <p>
     * the map is keyed by the name of the attribute and 
     * the value is the string value of the attribute.
     * 
     * the map returned by this method is live, and you can add new attribute
     * by updating the map directly. Because of this design, there's no setter.
     * 
     * 
     * @return
     *     always non-null
     */
    public Map<QName, String> getOtherAttributes() {
        return otherAttributes;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <simpleContent>
     *     <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>bitSteeringType">
     *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}string.prompt.att"/>
     *     </extension>
     *   </simpleContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "value"
    })
    public static class BitSteering {

        /**
         * Indicates whether bit steering should be used to map this interface onto a bus of different data width.
         * 
         * Values are "on", "off" (defaults to "off").
         * 
         */
        @XmlValue
        protected BitSteeringType value;
        /**
         * Provides a string used to prompt the user for user-resolved property values.
         * 
         */
        @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected String prompt;
        /**
         * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
         * 
         */
        @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected FormatType format;
        /**
         * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
         * 
         */
        @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected RangeTypeType rangeType;
        /**
         * For user defined properties, refers the choice element enumerating the values to choose from.
         * 
         */
        @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String choiceRef;
        /**
         * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
         * 
         */
        @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected Float order;
        /**
         * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
         * 
         */
        @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        @XmlSchemaType(name = "NMTOKENS")
        protected List<String> configGroups;
        /**
         * Length of the bit string, required if the format is bitString
         * 
         */
        @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        @XmlSchemaType(name = "nonNegativeInteger")
        protected BigInteger bitStringLength;
        /**
         * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
         * 
         */
        @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected String minimum;
        /**
         * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
         * 
         */
        @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected String maximum;
        /**
         * Determines how a property value is resolved.
         * 
         */
        @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected ResolveType resolve;
        /**
         * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
         * 
         */
        @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected String id;
        /**
         * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
         * 
         */
        @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
        protected String dependency;
        @XmlAnyAttribute
        private Map<QName, String> otherAttributes = new HashMap<>();

        /**
         * Indicates whether bit steering should be used to map this interface onto a bus of different data width.
         * 
         * Values are "on", "off" (defaults to "off").
         * 
         * @return
         *     possible object is
         *     {@link BitSteeringType }
         *     
         */
        public BitSteeringType getValue() {
            return value;
        }

        /**
         * Sets the value of the value property.
         * 
         * @param value
         *     allowed object is
         *     {@link BitSteeringType }
         *     
         * @see #getValue()
         */
        public void setValue(BitSteeringType value) {
            this.value = value;
        }

        /**
         * Provides a string used to prompt the user for user-resolved property values.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getPrompt() {
            return prompt;
        }

        /**
         * Sets the value of the prompt property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getPrompt()
         */
        public void setPrompt(String value) {
            this.prompt = value;
        }

        /**
         * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
         * 
         * @return
         *     possible object is
         *     {@link FormatType }
         *     
         */
        public FormatType getFormat() {
            if (format == null) {
                return FormatType.STRING;
            } else {
                return format;
            }
        }

        /**
         * Sets the value of the format property.
         * 
         * @param value
         *     allowed object is
         *     {@link FormatType }
         *     
         * @see #getFormat()
         */
        public void setFormat(FormatType value) {
            this.format = value;
        }

        /**
         * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
         * 
         * @return
         *     possible object is
         *     {@link RangeTypeType }
         *     
         */
        public RangeTypeType getRangeType() {
            if (rangeType == null) {
                return RangeTypeType.FLOAT;
            } else {
                return rangeType;
            }
        }

        /**
         * Sets the value of the rangeType property.
         * 
         * @param value
         *     allowed object is
         *     {@link RangeTypeType }
         *     
         * @see #getRangeType()
         */
        public void setRangeType(RangeTypeType value) {
            this.rangeType = value;
        }

        /**
         * For user defined properties, refers the choice element enumerating the values to choose from.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getChoiceRef() {
            return choiceRef;
        }

        /**
         * Sets the value of the choiceRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getChoiceRef()
         */
        public void setChoiceRef(String value) {
            this.choiceRef = value;
        }

        /**
         * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
         * 
         * @return
         *     possible object is
         *     {@link Float }
         *     
         */
        public Float getOrder() {
            return order;
        }

        /**
         * Sets the value of the order property.
         * 
         * @param value
         *     allowed object is
         *     {@link Float }
         *     
         * @see #getOrder()
         */
        public void setOrder(Float value) {
            this.order = value;
        }

        /**
         * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
         * 
         * Gets the value of the configGroups property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getConfigGroups().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * </p>
         * 
         * 
         * @return
         *     The value of the configGroups property.
         */
        public List<String> getConfigGroups() {
            if (configGroups == null) {
                configGroups = new ArrayList<>();
            }
            return this.configGroups;
        }

        /**
         * Length of the bit string, required if the format is bitString
         * 
         * @return
         *     possible object is
         *     {@link BigInteger }
         *     
         */
        public BigInteger getBitStringLength() {
            return bitStringLength;
        }

        /**
         * Sets the value of the bitStringLength property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigInteger }
         *     
         * @see #getBitStringLength()
         */
        public void setBitStringLength(BigInteger value) {
            this.bitStringLength = value;
        }

        /**
         * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getMinimum() {
            return minimum;
        }

        /**
         * Sets the value of the minimum property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getMinimum()
         */
        public void setMinimum(String value) {
            this.minimum = value;
        }

        /**
         * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getMaximum() {
            return maximum;
        }

        /**
         * Sets the value of the maximum property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getMaximum()
         */
        public void setMaximum(String value) {
            this.maximum = value;
        }

        /**
         * Determines how a property value is resolved.
         * 
         * @return
         *     possible object is
         *     {@link ResolveType }
         *     
         */
        public ResolveType getResolve() {
            if (resolve == null) {
                return ResolveType.IMMEDIATE;
            } else {
                return resolve;
            }
        }

        /**
         * Sets the value of the resolve property.
         * 
         * @param value
         *     allowed object is
         *     {@link ResolveType }
         *     
         * @see #getResolve()
         */
        public void setResolve(ResolveType value) {
            this.resolve = value;
        }

        /**
         * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getId() {
            return id;
        }

        /**
         * Sets the value of the id property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getId()
         */
        public void setId(String value) {
            this.id = value;
        }

        /**
         * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDependency() {
            return dependency;
        }

        /**
         * Sets the value of the dependency property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getDependency()
         */
        public void setDependency(String value) {
            this.dependency = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="addressSpaceRef" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <extension base="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addrSpaceRefType">
     *                 <sequence>
     *                   <element name="baseAddress" minOccurs="0">
     *                     <complexType>
     *                       <simpleContent>
     *                         <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledInteger">
     *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.att"/>
     *                           <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt default="Base Address:""/>
     *                         </extension>
     *                       </simpleContent>
     *                     </complexType>
     *                   </element>
     *                 </sequence>
     *               </extension>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "addressSpaceRef"
    })
    public static class Master {

        /**
         * If this master connects to an addressable bus, this element references the address space it maps to.
         * 
         */
        protected BusInterfaceType.Master.AddressSpaceRef addressSpaceRef;

        /**
         * If this master connects to an addressable bus, this element references the address space it maps to.
         * 
         * @return
         *     possible object is
         *     {@link BusInterfaceType.Master.AddressSpaceRef }
         *     
         */
        public BusInterfaceType.Master.AddressSpaceRef getAddressSpaceRef() {
            return addressSpaceRef;
        }

        /**
         * Sets the value of the addressSpaceRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link BusInterfaceType.Master.AddressSpaceRef }
         *     
         * @see #getAddressSpaceRef()
         */
        public void setAddressSpaceRef(BusInterfaceType.Master.AddressSpaceRef value) {
            this.addressSpaceRef = value;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <extension base="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}addrSpaceRefType">
         *       <sequence>
         *         <element name="baseAddress" minOccurs="0">
         *           <complexType>
         *             <simpleContent>
         *               <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledInteger">
         *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.att"/>
         *                 <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt default="Base Address:""/>
         *               </extension>
         *             </simpleContent>
         *           </complexType>
         *         </element>
         *       </sequence>
         *     </extension>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "baseAddress"
        })
        public static class AddressSpaceRef
            extends AddrSpaceRefType
        {

            /**
             * Base of an address space.
             * 
             */
            protected BusInterfaceType.Master.AddressSpaceRef.BaseAddress baseAddress;

            /**
             * Base of an address space.
             * 
             * @return
             *     possible object is
             *     {@link BusInterfaceType.Master.AddressSpaceRef.BaseAddress }
             *     
             */
            public BusInterfaceType.Master.AddressSpaceRef.BaseAddress getBaseAddress() {
                return baseAddress;
            }

            /**
             * Sets the value of the baseAddress property.
             * 
             * @param value
             *     allowed object is
             *     {@link BusInterfaceType.Master.AddressSpaceRef.BaseAddress }
             *     
             * @see #getBaseAddress()
             */
            public void setBaseAddress(BusInterfaceType.Master.AddressSpaceRef.BaseAddress value) {
                this.baseAddress = value;
            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <simpleContent>
             *     <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledInteger">
             *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.att"/>
             *       <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt default="Base Address:""/>
             *     </extension>
             *   </simpleContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "value"
            })
            public static class BaseAddress {

                /**
                 * A scaled integer.  It supports any string recognized by java.lang.Long.decode().  It also supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                 * 
                 */
                @XmlValue
                protected String value;
                /**
                 * Provides a string used to prompt the user for user-resolved property values.
                 * 
                 */
                @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String prompt;
                /**
                 * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                 * 
                 */
                @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected FormatType format;
                /**
                 * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                 * 
                 */
                @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected RangeTypeType rangeType;
                /**
                 * For user defined properties, refers the choice element enumerating the values to choose from.
                 * 
                 */
                @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlSchemaType(name = "Name")
                protected String choiceRef;
                /**
                 * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                 * 
                 */
                @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected Float order;
                /**
                 * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                 * 
                 */
                @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlSchemaType(name = "NMTOKENS")
                protected List<String> configGroups;
                /**
                 * Length of the bit string, required if the format is bitString
                 * 
                 */
                @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlSchemaType(name = "nonNegativeInteger")
                protected BigInteger bitStringLength;
                /**
                 * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                 * 
                 */
                @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String minimum;
                /**
                 * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                 * 
                 */
                @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String maximum;
                /**
                 * Determines how a property value is resolved.
                 * 
                 */
                @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected ResolveType resolve;
                /**
                 * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                 * 
                 */
                @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlID
                @XmlSchemaType(name = "ID")
                protected String id;
                /**
                 * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                 * 
                 */
                @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String dependency;
                @XmlAnyAttribute
                private Map<QName, String> otherAttributes = new HashMap<>();

                /**
                 * A scaled integer.  It supports any string recognized by java.lang.Long.decode().  It also supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getValue() {
                    return value;
                }

                /**
                 * Sets the value of the value property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getValue()
                 */
                public void setValue(String value) {
                    this.value = value;
                }

                /**
                 * Provides a string used to prompt the user for user-resolved property values.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getPrompt() {
                    if (prompt == null) {
                        return "Base Address:";
                    } else {
                        return prompt;
                    }
                }

                /**
                 * Sets the value of the prompt property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getPrompt()
                 */
                public void setPrompt(String value) {
                    this.prompt = value;
                }

                /**
                 * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                 * 
                 * @return
                 *     possible object is
                 *     {@link FormatType }
                 *     
                 */
                public FormatType getFormat() {
                    if (format == null) {
                        return FormatType.LONG;
                    } else {
                        return format;
                    }
                }

                /**
                 * Sets the value of the format property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link FormatType }
                 *     
                 * @see #getFormat()
                 */
                public void setFormat(FormatType value) {
                    this.format = value;
                }

                /**
                 * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                 * 
                 * @return
                 *     possible object is
                 *     {@link RangeTypeType }
                 *     
                 */
                public RangeTypeType getRangeType() {
                    if (rangeType == null) {
                        return RangeTypeType.FLOAT;
                    } else {
                        return rangeType;
                    }
                }

                /**
                 * Sets the value of the rangeType property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link RangeTypeType }
                 *     
                 * @see #getRangeType()
                 */
                public void setRangeType(RangeTypeType value) {
                    this.rangeType = value;
                }

                /**
                 * For user defined properties, refers the choice element enumerating the values to choose from.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getChoiceRef() {
                    return choiceRef;
                }

                /**
                 * Sets the value of the choiceRef property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getChoiceRef()
                 */
                public void setChoiceRef(String value) {
                    this.choiceRef = value;
                }

                /**
                 * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                 * 
                 * @return
                 *     possible object is
                 *     {@link Float }
                 *     
                 */
                public Float getOrder() {
                    return order;
                }

                /**
                 * Sets the value of the order property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link Float }
                 *     
                 * @see #getOrder()
                 */
                public void setOrder(Float value) {
                    this.order = value;
                }

                /**
                 * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                 * 
                 * Gets the value of the configGroups property.
                 * 
                 * <p>This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object.
                 * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                 * 
                 * <p>
                 * For example, to add a new item, do as follows:
                 * </p>
                 * <pre>
                 * getConfigGroups().add(newItem);
                 * </pre>
                 * 
                 * 
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link String }
                 * </p>
                 * 
                 * 
                 * @return
                 *     The value of the configGroups property.
                 */
                public List<String> getConfigGroups() {
                    if (configGroups == null) {
                        configGroups = new ArrayList<>();
                    }
                    return this.configGroups;
                }

                /**
                 * Length of the bit string, required if the format is bitString
                 * 
                 * @return
                 *     possible object is
                 *     {@link BigInteger }
                 *     
                 */
                public BigInteger getBitStringLength() {
                    return bitStringLength;
                }

                /**
                 * Sets the value of the bitStringLength property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link BigInteger }
                 *     
                 * @see #getBitStringLength()
                 */
                public void setBitStringLength(BigInteger value) {
                    this.bitStringLength = value;
                }

                /**
                 * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getMinimum() {
                    return minimum;
                }

                /**
                 * Sets the value of the minimum property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getMinimum()
                 */
                public void setMinimum(String value) {
                    this.minimum = value;
                }

                /**
                 * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getMaximum() {
                    return maximum;
                }

                /**
                 * Sets the value of the maximum property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getMaximum()
                 */
                public void setMaximum(String value) {
                    this.maximum = value;
                }

                /**
                 * Determines how a property value is resolved.
                 * 
                 * @return
                 *     possible object is
                 *     {@link ResolveType }
                 *     
                 */
                public ResolveType getResolve() {
                    if (resolve == null) {
                        return ResolveType.IMMEDIATE;
                    } else {
                        return resolve;
                    }
                }

                /**
                 * Sets the value of the resolve property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link ResolveType }
                 *     
                 * @see #getResolve()
                 */
                public void setResolve(ResolveType value) {
                    this.resolve = value;
                }

                /**
                 * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getId() {
                    return id;
                }

                /**
                 * Sets the value of the id property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getId()
                 */
                public void setId(String value) {
                    this.id = value;
                }

                /**
                 * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getDependency() {
                    return dependency;
                }

                /**
                 * Sets the value of the dependency property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getDependency()
                 */
                public void setDependency(String value) {
                    this.dependency = value;
                }

                /**
                 * Gets a map that contains attributes that aren't bound to any typed property on this class.
                 * 
                 * <p>
                 * the map is keyed by the name of the attribute and 
                 * the value is the string value of the attribute.
                 * 
                 * the map returned by this method is live, and you can add new attribute
                 * by updating the map directly. Because of this design, there's no setter.
                 * 
                 * 
                 * @return
                 *     always non-null
                 */
                public Map<QName, String> getOtherAttributes() {
                    return otherAttributes;
                }

            }

        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class MirroredMaster {


    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence minOccurs="0">
     *         <element name="baseAddresses" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <sequence>
     *                   <element name="remapAddress" maxOccurs="unbounded">
     *                     <complexType>
     *                       <simpleContent>
     *                         <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
     *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.att"/>
     *                           <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt default="Base Address:""/>
     *                           <attribute name="state" type="{http://www.w3.org/2001/XMLSchema}string" />
     *                         </extension>
     *                       </simpleContent>
     *                     </complexType>
     *                   </element>
     *                   <element name="range">
     *                     <complexType>
     *                       <simpleContent>
     *                         <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
     *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
     *                         </extension>
     *                       </simpleContent>
     *                     </complexType>
     *                   </element>
     *                 </sequence>
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "baseAddresses"
    })
    public static class MirroredSlave {

        /**
         * Represents a set of remap base addresses.
         * 
         */
        protected BusInterfaceType.MirroredSlave.BaseAddresses baseAddresses;

        /**
         * Represents a set of remap base addresses.
         * 
         * @return
         *     possible object is
         *     {@link BusInterfaceType.MirroredSlave.BaseAddresses }
         *     
         */
        public BusInterfaceType.MirroredSlave.BaseAddresses getBaseAddresses() {
            return baseAddresses;
        }

        /**
         * Sets the value of the baseAddresses property.
         * 
         * @param value
         *     allowed object is
         *     {@link BusInterfaceType.MirroredSlave.BaseAddresses }
         *     
         * @see #getBaseAddresses()
         */
        public void setBaseAddresses(BusInterfaceType.MirroredSlave.BaseAddresses value) {
            this.baseAddresses = value;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <sequence>
         *         <element name="remapAddress" maxOccurs="unbounded">
         *           <complexType>
         *             <simpleContent>
         *               <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
         *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.att"/>
         *                 <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt default="Base Address:""/>
         *                 <attribute name="state" type="{http://www.w3.org/2001/XMLSchema}string" />
         *               </extension>
         *             </simpleContent>
         *           </complexType>
         *         </element>
         *         <element name="range">
         *           <complexType>
         *             <simpleContent>
         *               <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
         *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
         *               </extension>
         *             </simpleContent>
         *           </complexType>
         *         </element>
         *       </sequence>
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "remapAddress",
            "range"
        })
        public static class BaseAddresses {

            /**
             * Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid.
             * 
             */
            @XmlElement(required = true)
            protected List<BusInterfaceType.MirroredSlave.BaseAddresses.RemapAddress> remapAddress;
            /**
             * The address range of mirrored slave, expressed as the number of bitsInLAU from the containing busInterface.
             * 
             */
            @XmlElement(required = true)
            protected BusInterfaceType.MirroredSlave.BaseAddresses.Range range;

            /**
             * Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid.
             * 
             * Gets the value of the remapAddress property.
             * 
             * <p>This accessor method returns a reference to the live list,
             * not a snapshot. Therefore any modification you make to the
             * returned list will be present inside the JAXB object.
             * This is why there is not a <CODE>set</CODE> method for the remapAddress property.</p>
             * 
             * <p>
             * For example, to add a new item, do as follows:
             * </p>
             * <pre>
             * getRemapAddress().add(newItem);
             * </pre>
             * 
             * 
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link BusInterfaceType.MirroredSlave.BaseAddresses.RemapAddress }
             * </p>
             * 
             * 
             * @return
             *     The value of the remapAddress property.
             */
            public List<BusInterfaceType.MirroredSlave.BaseAddresses.RemapAddress> getRemapAddress() {
                if (remapAddress == null) {
                    remapAddress = new ArrayList<>();
                }
                return this.remapAddress;
            }

            /**
             * The address range of mirrored slave, expressed as the number of bitsInLAU from the containing busInterface.
             * 
             * @return
             *     possible object is
             *     {@link BusInterfaceType.MirroredSlave.BaseAddresses.Range }
             *     
             */
            public BusInterfaceType.MirroredSlave.BaseAddresses.Range getRange() {
                return range;
            }

            /**
             * Sets the value of the range property.
             * 
             * @param value
             *     allowed object is
             *     {@link BusInterfaceType.MirroredSlave.BaseAddresses.Range }
             *     
             * @see #getRange()
             */
            public void setRange(BusInterfaceType.MirroredSlave.BaseAddresses.Range value) {
                this.range = value;
            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <simpleContent>
             *     <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledPositiveInteger">
             *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
             *     </extension>
             *   </simpleContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "value"
            })
            public static class Range {

                /**
                 * A scaled positive integer that consists of the value set {1, 2, ...}.  It is derived from scaledNonNegativeInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                 * 
                 */
                @XmlValue
                protected String value;
                /**
                 * Provides a string used to prompt the user for user-resolved property values.
                 * 
                 */
                @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String prompt;
                /**
                 * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                 * 
                 */
                @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected FormatType format;
                /**
                 * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                 * 
                 */
                @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected RangeTypeType rangeType;
                /**
                 * For user defined properties, refers the choice element enumerating the values to choose from.
                 * 
                 */
                @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlSchemaType(name = "Name")
                protected String choiceRef;
                /**
                 * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                 * 
                 */
                @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected Float order;
                /**
                 * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                 * 
                 */
                @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlSchemaType(name = "NMTOKENS")
                protected List<String> configGroups;
                /**
                 * Length of the bit string, required if the format is bitString
                 * 
                 */
                @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlSchemaType(name = "nonNegativeInteger")
                protected BigInteger bitStringLength;
                /**
                 * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                 * 
                 */
                @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String minimum;
                /**
                 * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                 * 
                 */
                @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String maximum;
                /**
                 * Determines how a property value is resolved.
                 * 
                 */
                @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected ResolveType resolve;
                /**
                 * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                 * 
                 */
                @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlID
                @XmlSchemaType(name = "ID")
                protected String id;
                /**
                 * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                 * 
                 */
                @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String dependency;
                @XmlAnyAttribute
                private Map<QName, String> otherAttributes = new HashMap<>();

                /**
                 * A scaled positive integer that consists of the value set {1, 2, ...}.  It is derived from scaledNonNegativeInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getValue() {
                    return value;
                }

                /**
                 * Sets the value of the value property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getValue()
                 */
                public void setValue(String value) {
                    this.value = value;
                }

                /**
                 * Provides a string used to prompt the user for user-resolved property values.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getPrompt() {
                    return prompt;
                }

                /**
                 * Sets the value of the prompt property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getPrompt()
                 */
                public void setPrompt(String value) {
                    this.prompt = value;
                }

                /**
                 * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                 * 
                 * @return
                 *     possible object is
                 *     {@link FormatType }
                 *     
                 */
                public FormatType getFormat() {
                    if (format == null) {
                        return FormatType.LONG;
                    } else {
                        return format;
                    }
                }

                /**
                 * Sets the value of the format property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link FormatType }
                 *     
                 * @see #getFormat()
                 */
                public void setFormat(FormatType value) {
                    this.format = value;
                }

                /**
                 * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                 * 
                 * @return
                 *     possible object is
                 *     {@link RangeTypeType }
                 *     
                 */
                public RangeTypeType getRangeType() {
                    if (rangeType == null) {
                        return RangeTypeType.FLOAT;
                    } else {
                        return rangeType;
                    }
                }

                /**
                 * Sets the value of the rangeType property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link RangeTypeType }
                 *     
                 * @see #getRangeType()
                 */
                public void setRangeType(RangeTypeType value) {
                    this.rangeType = value;
                }

                /**
                 * For user defined properties, refers the choice element enumerating the values to choose from.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getChoiceRef() {
                    return choiceRef;
                }

                /**
                 * Sets the value of the choiceRef property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getChoiceRef()
                 */
                public void setChoiceRef(String value) {
                    this.choiceRef = value;
                }

                /**
                 * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                 * 
                 * @return
                 *     possible object is
                 *     {@link Float }
                 *     
                 */
                public Float getOrder() {
                    return order;
                }

                /**
                 * Sets the value of the order property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link Float }
                 *     
                 * @see #getOrder()
                 */
                public void setOrder(Float value) {
                    this.order = value;
                }

                /**
                 * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                 * 
                 * Gets the value of the configGroups property.
                 * 
                 * <p>This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object.
                 * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                 * 
                 * <p>
                 * For example, to add a new item, do as follows:
                 * </p>
                 * <pre>
                 * getConfigGroups().add(newItem);
                 * </pre>
                 * 
                 * 
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link String }
                 * </p>
                 * 
                 * 
                 * @return
                 *     The value of the configGroups property.
                 */
                public List<String> getConfigGroups() {
                    if (configGroups == null) {
                        configGroups = new ArrayList<>();
                    }
                    return this.configGroups;
                }

                /**
                 * Length of the bit string, required if the format is bitString
                 * 
                 * @return
                 *     possible object is
                 *     {@link BigInteger }
                 *     
                 */
                public BigInteger getBitStringLength() {
                    return bitStringLength;
                }

                /**
                 * Sets the value of the bitStringLength property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link BigInteger }
                 *     
                 * @see #getBitStringLength()
                 */
                public void setBitStringLength(BigInteger value) {
                    this.bitStringLength = value;
                }

                /**
                 * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getMinimum() {
                    return minimum;
                }

                /**
                 * Sets the value of the minimum property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getMinimum()
                 */
                public void setMinimum(String value) {
                    this.minimum = value;
                }

                /**
                 * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getMaximum() {
                    return maximum;
                }

                /**
                 * Sets the value of the maximum property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getMaximum()
                 */
                public void setMaximum(String value) {
                    this.maximum = value;
                }

                /**
                 * Determines how a property value is resolved.
                 * 
                 * @return
                 *     possible object is
                 *     {@link ResolveType }
                 *     
                 */
                public ResolveType getResolve() {
                    if (resolve == null) {
                        return ResolveType.IMMEDIATE;
                    } else {
                        return resolve;
                    }
                }

                /**
                 * Sets the value of the resolve property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link ResolveType }
                 *     
                 * @see #getResolve()
                 */
                public void setResolve(ResolveType value) {
                    this.resolve = value;
                }

                /**
                 * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getId() {
                    return id;
                }

                /**
                 * Sets the value of the id property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getId()
                 */
                public void setId(String value) {
                    this.id = value;
                }

                /**
                 * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getDependency() {
                    return dependency;
                }

                /**
                 * Sets the value of the dependency property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getDependency()
                 */
                public void setDependency(String value) {
                    this.dependency = value;
                }

                /**
                 * Gets a map that contains attributes that aren't bound to any typed property on this class.
                 * 
                 * <p>
                 * the map is keyed by the name of the attribute and 
                 * the value is the string value of the attribute.
                 * 
                 * the map returned by this method is live, and you can add new attribute
                 * by updating the map directly. Because of this design, there's no setter.
                 * 
                 * 
                 * @return
                 *     always non-null
                 */
                public Map<QName, String> getOtherAttributes() {
                    return otherAttributes;
                }

            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <simpleContent>
             *     <extension base="<http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009>scaledNonNegativeInteger">
             *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.att"/>
             *       <attribute ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}prompt default="Base Address:""/>
             *       <attribute name="state" type="{http://www.w3.org/2001/XMLSchema}string" />
             *     </extension>
             *   </simpleContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "value"
            })
            public static class RemapAddress {

                /**
                 * A scaled nonnegative integer that consists of the value set {0, 1, ...}.  It is derived from scaledInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                 * 
                 */
                @XmlValue
                protected String value;
                /**
                 * Provides a string used to prompt the user for user-resolved property values.
                 * 
                 */
                @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String prompt;
                /**
                 * Name of the state in which this remapped address range is valid
                 * 
                 */
                @XmlAttribute(name = "state", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String state;
                /**
                 * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                 * 
                 */
                @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected FormatType format;
                /**
                 * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                 * 
                 */
                @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected RangeTypeType rangeType;
                /**
                 * For user defined properties, refers the choice element enumerating the values to choose from.
                 * 
                 */
                @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlSchemaType(name = "Name")
                protected String choiceRef;
                /**
                 * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                 * 
                 */
                @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected Float order;
                /**
                 * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                 * 
                 */
                @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlSchemaType(name = "NMTOKENS")
                protected List<String> configGroups;
                /**
                 * Length of the bit string, required if the format is bitString
                 * 
                 */
                @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlSchemaType(name = "nonNegativeInteger")
                protected BigInteger bitStringLength;
                /**
                 * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                 * 
                 */
                @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String minimum;
                /**
                 * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                 * 
                 */
                @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String maximum;
                /**
                 * Determines how a property value is resolved.
                 * 
                 */
                @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected ResolveType resolve;
                /**
                 * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                 * 
                 */
                @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlID
                @XmlSchemaType(name = "ID")
                protected String id;
                /**
                 * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                 * 
                 */
                @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                protected String dependency;
                @XmlAnyAttribute
                private Map<QName, String> otherAttributes = new HashMap<>();

                /**
                 * A scaled nonnegative integer that consists of the value set {0, 1, ...}.  It is derived from scaledInteger and it supports a magnitude scale suffix of upper or lower case K (kilo=2^10), M (mega=2^20), G (giga=2^30) or T (tera=2^40).
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getValue() {
                    return value;
                }

                /**
                 * Sets the value of the value property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getValue()
                 */
                public void setValue(String value) {
                    this.value = value;
                }

                /**
                 * Provides a string used to prompt the user for user-resolved property values.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getPrompt() {
                    if (prompt == null) {
                        return "Base Address:";
                    } else {
                        return prompt;
                    }
                }

                /**
                 * Sets the value of the prompt property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getPrompt()
                 */
                public void setPrompt(String value) {
                    this.prompt = value;
                }

                /**
                 * Name of the state in which this remapped address range is valid
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getState() {
                    return state;
                }

                /**
                 * Sets the value of the state property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getState()
                 */
                public void setState(String value) {
                    this.state = value;
                }

                /**
                 * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                 * 
                 * @return
                 *     possible object is
                 *     {@link FormatType }
                 *     
                 */
                public FormatType getFormat() {
                    if (format == null) {
                        return FormatType.LONG;
                    } else {
                        return format;
                    }
                }

                /**
                 * Sets the value of the format property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link FormatType }
                 *     
                 * @see #getFormat()
                 */
                public void setFormat(FormatType value) {
                    this.format = value;
                }

                /**
                 * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                 * 
                 * @return
                 *     possible object is
                 *     {@link RangeTypeType }
                 *     
                 */
                public RangeTypeType getRangeType() {
                    if (rangeType == null) {
                        return RangeTypeType.FLOAT;
                    } else {
                        return rangeType;
                    }
                }

                /**
                 * Sets the value of the rangeType property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link RangeTypeType }
                 *     
                 * @see #getRangeType()
                 */
                public void setRangeType(RangeTypeType value) {
                    this.rangeType = value;
                }

                /**
                 * For user defined properties, refers the choice element enumerating the values to choose from.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getChoiceRef() {
                    return choiceRef;
                }

                /**
                 * Sets the value of the choiceRef property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getChoiceRef()
                 */
                public void setChoiceRef(String value) {
                    this.choiceRef = value;
                }

                /**
                 * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                 * 
                 * @return
                 *     possible object is
                 *     {@link Float }
                 *     
                 */
                public Float getOrder() {
                    return order;
                }

                /**
                 * Sets the value of the order property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link Float }
                 *     
                 * @see #getOrder()
                 */
                public void setOrder(Float value) {
                    this.order = value;
                }

                /**
                 * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                 * 
                 * Gets the value of the configGroups property.
                 * 
                 * <p>This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object.
                 * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                 * 
                 * <p>
                 * For example, to add a new item, do as follows:
                 * </p>
                 * <pre>
                 * getConfigGroups().add(newItem);
                 * </pre>
                 * 
                 * 
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link String }
                 * </p>
                 * 
                 * 
                 * @return
                 *     The value of the configGroups property.
                 */
                public List<String> getConfigGroups() {
                    if (configGroups == null) {
                        configGroups = new ArrayList<>();
                    }
                    return this.configGroups;
                }

                /**
                 * Length of the bit string, required if the format is bitString
                 * 
                 * @return
                 *     possible object is
                 *     {@link BigInteger }
                 *     
                 */
                public BigInteger getBitStringLength() {
                    return bitStringLength;
                }

                /**
                 * Sets the value of the bitStringLength property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link BigInteger }
                 *     
                 * @see #getBitStringLength()
                 */
                public void setBitStringLength(BigInteger value) {
                    this.bitStringLength = value;
                }

                /**
                 * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getMinimum() {
                    return minimum;
                }

                /**
                 * Sets the value of the minimum property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getMinimum()
                 */
                public void setMinimum(String value) {
                    this.minimum = value;
                }

                /**
                 * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getMaximum() {
                    return maximum;
                }

                /**
                 * Sets the value of the maximum property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getMaximum()
                 */
                public void setMaximum(String value) {
                    this.maximum = value;
                }

                /**
                 * Determines how a property value is resolved.
                 * 
                 * @return
                 *     possible object is
                 *     {@link ResolveType }
                 *     
                 */
                public ResolveType getResolve() {
                    if (resolve == null) {
                        return ResolveType.IMMEDIATE;
                    } else {
                        return resolve;
                    }
                }

                /**
                 * Sets the value of the resolve property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link ResolveType }
                 *     
                 * @see #getResolve()
                 */
                public void setResolve(ResolveType value) {
                    this.resolve = value;
                }

                /**
                 * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getId() {
                    return id;
                }

                /**
                 * Sets the value of the id property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getId()
                 */
                public void setId(String value) {
                    this.id = value;
                }

                /**
                 * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getDependency() {
                    return dependency;
                }

                /**
                 * Sets the value of the dependency property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getDependency()
                 */
                public void setDependency(String value) {
                    this.dependency = value;
                }

                /**
                 * Gets a map that contains attributes that aren't bound to any typed property on this class.
                 * 
                 * <p>
                 * the map is keyed by the name of the attribute and 
                 * the value is the string value of the attribute.
                 * 
                 * the map returned by this method is live, and you can add new attribute
                 * by updating the map directly. Because of this design, there's no setter.
                 * 
                 * 
                 * @return
                 *     always non-null
                 */
                public Map<QName, String> getOtherAttributes() {
                    return otherAttributes;
                }

            }

        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}group"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "group"
    })
    public static class MirroredSystem {

        /**
         * Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.
         * 
         */
        @XmlElement(required = true)
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String group;

        /**
         * Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getGroup() {
            return group;
        }

        /**
         * Sets the value of the group property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getGroup()
         */
        public void setGroup(String value) {
            this.group = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}group" minOccurs="0"/>
     *       </sequence>
     *       <attribute name="interfaceMode" use="required">
     *         <simpleType>
     *           <restriction base="{http://www.w3.org/2001/XMLSchema}token">
     *             <enumeration value="master"/>
     *             <enumeration value="slave"/>
     *             <enumeration value="system"/>
     *             <enumeration value="mirroredMaster"/>
     *             <enumeration value="mirroredSlave"/>
     *             <enumeration value="mirroredSystem"/>
     *           </restriction>
     *         </simpleType>
     *       </attribute>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "group"
    })
    public static class Monitor {

        /**
         * Indicates which system interface is being monitored. Name must match a group name present on one or more ports in the corresonding bus definition.
         * 
         */
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String group;
        @XmlAttribute(name = "interfaceMode", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009", required = true)
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        protected String interfaceMode;

        /**
         * Indicates which system interface is being monitored. Name must match a group name present on one or more ports in the corresonding bus definition.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getGroup() {
            return group;
        }

        /**
         * Sets the value of the group property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getGroup()
         */
        public void setGroup(String value) {
            this.group = value;
        }

        /**
         * Gets the value of the interfaceMode property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getInterfaceMode() {
            return interfaceMode;
        }

        /**
         * Sets the value of the interfaceMode property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setInterfaceMode(String value) {
            this.interfaceMode = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="portMap" maxOccurs="unbounded">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <sequence>
     *                   <element name="logicalPort">
     *                     <complexType>
     *                       <complexContent>
     *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                           <sequence>
     *                             <element name="name" type="{http://www.w3.org/2001/XMLSchema}Name"/>
     *                             <element name="vector" minOccurs="0">
     *                               <complexType>
     *                                 <complexContent>
     *                                   <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                                     <sequence>
     *                                       <element name="left">
     *                                         <complexType>
     *                                           <simpleContent>
     *                                             <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
     *                                               <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
     *                                             </extension>
     *                                           </simpleContent>
     *                                         </complexType>
     *                                       </element>
     *                                       <element name="right">
     *                                         <complexType>
     *                                           <simpleContent>
     *                                             <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
     *                                               <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
     *                                             </extension>
     *                                           </simpleContent>
     *                                         </complexType>
     *                                       </element>
     *                                     </sequence>
     *                                   </restriction>
     *                                 </complexContent>
     *                               </complexType>
     *                             </element>
     *                           </sequence>
     *                         </restriction>
     *                       </complexContent>
     *                     </complexType>
     *                   </element>
     *                   <element name="physicalPort">
     *                     <complexType>
     *                       <complexContent>
     *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                           <sequence>
     *                             <element name="name" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portName"/>
     *                             <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vector" minOccurs="0"/>
     *                           </sequence>
     *                         </restriction>
     *                       </complexContent>
     *                     </complexType>
     *                   </element>
     *                 </sequence>
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "portMap"
    })
    public static class PortMaps {

        /**
         * Maps a component's port to a port in a bus description. This is the logical to physical mapping. The logical pin comes from the bus interface and the physical pin from the component.
         * 
         */
        @XmlElement(required = true)
        protected List<BusInterfaceType.PortMaps.PortMap> portMap;

        /**
         * Maps a component's port to a port in a bus description. This is the logical to physical mapping. The logical pin comes from the bus interface and the physical pin from the component.
         * 
         * Gets the value of the portMap property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the portMap property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getPortMap().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link BusInterfaceType.PortMaps.PortMap }
         * </p>
         * 
         * 
         * @return
         *     The value of the portMap property.
         */
        public List<BusInterfaceType.PortMaps.PortMap> getPortMap() {
            if (portMap == null) {
                portMap = new ArrayList<>();
            }
            return this.portMap;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <sequence>
         *         <element name="logicalPort">
         *           <complexType>
         *             <complexContent>
         *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                 <sequence>
         *                   <element name="name" type="{http://www.w3.org/2001/XMLSchema}Name"/>
         *                   <element name="vector" minOccurs="0">
         *                     <complexType>
         *                       <complexContent>
         *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                           <sequence>
         *                             <element name="left">
         *                               <complexType>
         *                                 <simpleContent>
         *                                   <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
         *                                     <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
         *                                   </extension>
         *                                 </simpleContent>
         *                               </complexType>
         *                             </element>
         *                             <element name="right">
         *                               <complexType>
         *                                 <simpleContent>
         *                                   <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
         *                                     <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
         *                                   </extension>
         *                                 </simpleContent>
         *                               </complexType>
         *                             </element>
         *                           </sequence>
         *                         </restriction>
         *                       </complexContent>
         *                     </complexType>
         *                   </element>
         *                 </sequence>
         *               </restriction>
         *             </complexContent>
         *           </complexType>
         *         </element>
         *         <element name="physicalPort">
         *           <complexType>
         *             <complexContent>
         *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *                 <sequence>
         *                   <element name="name" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portName"/>
         *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vector" minOccurs="0"/>
         *                 </sequence>
         *               </restriction>
         *             </complexContent>
         *           </complexType>
         *         </element>
         *       </sequence>
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "logicalPort",
            "physicalPort"
        })
        public static class PortMap {

            /**
             * Logical port from abstraction definition
             * 
             */
            @XmlElement(required = true)
            protected BusInterfaceType.PortMaps.PortMap.LogicalPort logicalPort;
            /**
             * Physical port from this component
             * 
             */
            @XmlElement(required = true)
            protected BusInterfaceType.PortMaps.PortMap.PhysicalPort physicalPort;

            /**
             * Logical port from abstraction definition
             * 
             * @return
             *     possible object is
             *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort }
             *     
             */
            public BusInterfaceType.PortMaps.PortMap.LogicalPort getLogicalPort() {
                return logicalPort;
            }

            /**
             * Sets the value of the logicalPort property.
             * 
             * @param value
             *     allowed object is
             *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort }
             *     
             * @see #getLogicalPort()
             */
            public void setLogicalPort(BusInterfaceType.PortMaps.PortMap.LogicalPort value) {
                this.logicalPort = value;
            }

            /**
             * Physical port from this component
             * 
             * @return
             *     possible object is
             *     {@link BusInterfaceType.PortMaps.PortMap.PhysicalPort }
             *     
             */
            public BusInterfaceType.PortMaps.PortMap.PhysicalPort getPhysicalPort() {
                return physicalPort;
            }

            /**
             * Sets the value of the physicalPort property.
             * 
             * @param value
             *     allowed object is
             *     {@link BusInterfaceType.PortMaps.PortMap.PhysicalPort }
             *     
             * @see #getPhysicalPort()
             */
            public void setPhysicalPort(BusInterfaceType.PortMaps.PortMap.PhysicalPort value) {
                this.physicalPort = value;
            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <complexContent>
             *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *       <sequence>
             *         <element name="name" type="{http://www.w3.org/2001/XMLSchema}Name"/>
             *         <element name="vector" minOccurs="0">
             *           <complexType>
             *             <complexContent>
             *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *                 <sequence>
             *                   <element name="left">
             *                     <complexType>
             *                       <simpleContent>
             *                         <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
             *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
             *                         </extension>
             *                       </simpleContent>
             *                     </complexType>
             *                   </element>
             *                   <element name="right">
             *                     <complexType>
             *                       <simpleContent>
             *                         <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
             *                           <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
             *                         </extension>
             *                       </simpleContent>
             *                     </complexType>
             *                   </element>
             *                 </sequence>
             *               </restriction>
             *             </complexContent>
             *           </complexType>
             *         </element>
             *       </sequence>
             *     </restriction>
             *   </complexContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "name",
                "vector"
            })
            public static class LogicalPort {

                /**
                 * Bus port name as specified inside the abstraction definition
                 * 
                 */
                @XmlElement(required = true)
                @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                @XmlSchemaType(name = "Name")
                protected String name;
                /**
                 * Definition of the logical indecies for a vectored port.
                 * 
                 */
                protected BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector vector;

                /**
                 * Bus port name as specified inside the abstraction definition
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getName() {
                    return name;
                }

                /**
                 * Sets the value of the name property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getName()
                 */
                public void setName(String value) {
                    this.name = value;
                }

                /**
                 * Definition of the logical indecies for a vectored port.
                 * 
                 * @return
                 *     possible object is
                 *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector }
                 *     
                 */
                public BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector getVector() {
                    return vector;
                }

                /**
                 * Sets the value of the vector property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector }
                 *     
                 * @see #getVector()
                 */
                public void setVector(BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector value) {
                    this.vector = value;
                }


                /**
                 * <p>Java class for anonymous complex type</p>.
                 * 
                 * <p>The following schema fragment specifies the expected content contained within this class.</p>
                 * 
                 * <pre>{@code
                 * <complexType>
                 *   <complexContent>
                 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
                 *       <sequence>
                 *         <element name="left">
                 *           <complexType>
                 *             <simpleContent>
                 *               <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
                 *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
                 *               </extension>
                 *             </simpleContent>
                 *           </complexType>
                 *         </element>
                 *         <element name="right">
                 *           <complexType>
                 *             <simpleContent>
                 *               <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
                 *                 <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
                 *               </extension>
                 *             </simpleContent>
                 *           </complexType>
                 *         </element>
                 *       </sequence>
                 *     </restriction>
                 *   </complexContent>
                 * </complexType>
                 * }</pre>
                 * 
                 * 
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "", propOrder = {
                    "left",
                    "right"
                })
                public static class Vector {

                    /**
                     * Defines which logical bit maps to the physical left bit below
                     * 
                     */
                    @XmlElement(required = true)
                    protected BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Left left;
                    /**
                     * Defines which logical bit maps to the physical right bit below
                     * 
                     */
                    @XmlElement(required = true)
                    protected BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Right right;

                    /**
                     * Defines which logical bit maps to the physical left bit below
                     * 
                     * @return
                     *     possible object is
                     *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Left }
                     *     
                     */
                    public BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Left getLeft() {
                        return left;
                    }

                    /**
                     * Sets the value of the left property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Left }
                     *     
                     * @see #getLeft()
                     */
                    public void setLeft(BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Left value) {
                        this.left = value;
                    }

                    /**
                     * Defines which logical bit maps to the physical right bit below
                     * 
                     * @return
                     *     possible object is
                     *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Right }
                     *     
                     */
                    public BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Right getRight() {
                        return right;
                    }

                    /**
                     * Sets the value of the right property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Right }
                     *     
                     * @see #getRight()
                     */
                    public void setRight(BusInterfaceType.PortMaps.PortMap.LogicalPort.Vector.Right value) {
                        this.right = value;
                    }


                    /**
                     * <p>Java class for anonymous complex type</p>.
                     * 
                     * <p>The following schema fragment specifies the expected content contained within this class.</p>
                     * 
                     * <pre>{@code
                     * <complexType>
                     *   <simpleContent>
                     *     <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
                     *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
                     *     </extension>
                     *   </simpleContent>
                     * </complexType>
                     * }</pre>
                     * 
                     * 
                     */
                    @XmlAccessorType(XmlAccessType.FIELD)
                    @XmlType(name = "", propOrder = {
                        "value"
                    })
                    public static class Left {

                        @XmlValue
                        @XmlSchemaType(name = "nonNegativeInteger")
                        protected BigInteger value;
                        /**
                         * Provides a string used to prompt the user for user-resolved property values.
                         * 
                         */
                        @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String prompt;
                        /**
                         * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                         * 
                         */
                        @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected FormatType format;
                        /**
                         * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                         * 
                         */
                        @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected RangeTypeType rangeType;
                        /**
                         * For user defined properties, refers the choice element enumerating the values to choose from.
                         * 
                         */
                        @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                        @XmlSchemaType(name = "Name")
                        protected String choiceRef;
                        /**
                         * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                         * 
                         */
                        @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected Float order;
                        /**
                         * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                         * 
                         */
                        @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlSchemaType(name = "NMTOKENS")
                        protected List<String> configGroups;
                        /**
                         * Length of the bit string, required if the format is bitString
                         * 
                         */
                        @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlSchemaType(name = "nonNegativeInteger")
                        protected BigInteger bitStringLength;
                        /**
                         * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                         * 
                         */
                        @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String minimum;
                        /**
                         * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                         * 
                         */
                        @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String maximum;
                        /**
                         * Determines how a property value is resolved.
                         * 
                         */
                        @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected ResolveType resolve;
                        /**
                         * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                         * 
                         */
                        @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                        @XmlID
                        @XmlSchemaType(name = "ID")
                        protected String id;
                        /**
                         * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                         * 
                         */
                        @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String dependency;
                        @XmlAnyAttribute
                        private Map<QName, String> otherAttributes = new HashMap<>();

                        /**
                         * Gets the value of the value property.
                         * 
                         * @return
                         *     possible object is
                         *     {@link BigInteger }
                         *     
                         */
                        public BigInteger getValue() {
                            return value;
                        }

                        /**
                         * Sets the value of the value property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link BigInteger }
                         *     
                         */
                        public void setValue(BigInteger value) {
                            this.value = value;
                        }

                        /**
                         * Provides a string used to prompt the user for user-resolved property values.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getPrompt() {
                            return prompt;
                        }

                        /**
                         * Sets the value of the prompt property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getPrompt()
                         */
                        public void setPrompt(String value) {
                            this.prompt = value;
                        }

                        /**
                         * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                         * 
                         * @return
                         *     possible object is
                         *     {@link FormatType }
                         *     
                         */
                        public FormatType getFormat() {
                            if (format == null) {
                                return FormatType.LONG;
                            } else {
                                return format;
                            }
                        }

                        /**
                         * Sets the value of the format property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link FormatType }
                         *     
                         * @see #getFormat()
                         */
                        public void setFormat(FormatType value) {
                            this.format = value;
                        }

                        /**
                         * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                         * 
                         * @return
                         *     possible object is
                         *     {@link RangeTypeType }
                         *     
                         */
                        public RangeTypeType getRangeType() {
                            if (rangeType == null) {
                                return RangeTypeType.FLOAT;
                            } else {
                                return rangeType;
                            }
                        }

                        /**
                         * Sets the value of the rangeType property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link RangeTypeType }
                         *     
                         * @see #getRangeType()
                         */
                        public void setRangeType(RangeTypeType value) {
                            this.rangeType = value;
                        }

                        /**
                         * For user defined properties, refers the choice element enumerating the values to choose from.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getChoiceRef() {
                            return choiceRef;
                        }

                        /**
                         * Sets the value of the choiceRef property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getChoiceRef()
                         */
                        public void setChoiceRef(String value) {
                            this.choiceRef = value;
                        }

                        /**
                         * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                         * 
                         * @return
                         *     possible object is
                         *     {@link Float }
                         *     
                         */
                        public Float getOrder() {
                            return order;
                        }

                        /**
                         * Sets the value of the order property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link Float }
                         *     
                         * @see #getOrder()
                         */
                        public void setOrder(Float value) {
                            this.order = value;
                        }

                        /**
                         * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                         * 
                         * Gets the value of the configGroups property.
                         * 
                         * <p>This accessor method returns a reference to the live list,
                         * not a snapshot. Therefore any modification you make to the
                         * returned list will be present inside the JAXB object.
                         * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                         * 
                         * <p>
                         * For example, to add a new item, do as follows:
                         * </p>
                         * <pre>
                         * getConfigGroups().add(newItem);
                         * </pre>
                         * 
                         * 
                         * <p>
                         * Objects of the following type(s) are allowed in the list
                         * {@link String }
                         * </p>
                         * 
                         * 
                         * @return
                         *     The value of the configGroups property.
                         */
                        public List<String> getConfigGroups() {
                            if (configGroups == null) {
                                configGroups = new ArrayList<>();
                            }
                            return this.configGroups;
                        }

                        /**
                         * Length of the bit string, required if the format is bitString
                         * 
                         * @return
                         *     possible object is
                         *     {@link BigInteger }
                         *     
                         */
                        public BigInteger getBitStringLength() {
                            return bitStringLength;
                        }

                        /**
                         * Sets the value of the bitStringLength property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link BigInteger }
                         *     
                         * @see #getBitStringLength()
                         */
                        public void setBitStringLength(BigInteger value) {
                            this.bitStringLength = value;
                        }

                        /**
                         * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getMinimum() {
                            return minimum;
                        }

                        /**
                         * Sets the value of the minimum property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getMinimum()
                         */
                        public void setMinimum(String value) {
                            this.minimum = value;
                        }

                        /**
                         * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getMaximum() {
                            return maximum;
                        }

                        /**
                         * Sets the value of the maximum property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getMaximum()
                         */
                        public void setMaximum(String value) {
                            this.maximum = value;
                        }

                        /**
                         * Determines how a property value is resolved.
                         * 
                         * @return
                         *     possible object is
                         *     {@link ResolveType }
                         *     
                         */
                        public ResolveType getResolve() {
                            if (resolve == null) {
                                return ResolveType.IMMEDIATE;
                            } else {
                                return resolve;
                            }
                        }

                        /**
                         * Sets the value of the resolve property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link ResolveType }
                         *     
                         * @see #getResolve()
                         */
                        public void setResolve(ResolveType value) {
                            this.resolve = value;
                        }

                        /**
                         * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getId() {
                            return id;
                        }

                        /**
                         * Sets the value of the id property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getId()
                         */
                        public void setId(String value) {
                            this.id = value;
                        }

                        /**
                         * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getDependency() {
                            return dependency;
                        }

                        /**
                         * Sets the value of the dependency property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getDependency()
                         */
                        public void setDependency(String value) {
                            this.dependency = value;
                        }

                        /**
                         * Gets a map that contains attributes that aren't bound to any typed property on this class.
                         * 
                         * <p>
                         * the map is keyed by the name of the attribute and 
                         * the value is the string value of the attribute.
                         * 
                         * the map returned by this method is live, and you can add new attribute
                         * by updating the map directly. Because of this design, there's no setter.
                         * 
                         * 
                         * @return
                         *     always non-null
                         */
                        public Map<QName, String> getOtherAttributes() {
                            return otherAttributes;
                        }

                    }


                    /**
                     * <p>Java class for anonymous complex type</p>.
                     * 
                     * <p>The following schema fragment specifies the expected content contained within this class.</p>
                     * 
                     * <pre>{@code
                     * <complexType>
                     *   <simpleContent>
                     *     <extension base="<http://www.w3.org/2001/XMLSchema>nonNegativeInteger">
                     *       <attGroup ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}long.prompt.att"/>
                     *     </extension>
                     *   </simpleContent>
                     * </complexType>
                     * }</pre>
                     * 
                     * 
                     */
                    @XmlAccessorType(XmlAccessType.FIELD)
                    @XmlType(name = "", propOrder = {
                        "value"
                    })
                    public static class Right {

                        @XmlValue
                        @XmlSchemaType(name = "nonNegativeInteger")
                        protected BigInteger value;
                        /**
                         * Provides a string used to prompt the user for user-resolved property values.
                         * 
                         */
                        @XmlAttribute(name = "prompt", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String prompt;
                        /**
                         * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                         * 
                         */
                        @XmlAttribute(name = "format", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected FormatType format;
                        /**
                         * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                         * 
                         */
                        @XmlAttribute(name = "rangeType", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected RangeTypeType rangeType;
                        /**
                         * For user defined properties, refers the choice element enumerating the values to choose from.
                         * 
                         */
                        @XmlAttribute(name = "choiceRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                        @XmlSchemaType(name = "Name")
                        protected String choiceRef;
                        /**
                         * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                         * 
                         */
                        @XmlAttribute(name = "order", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected Float order;
                        /**
                         * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                         * 
                         */
                        @XmlAttribute(name = "configGroups", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlSchemaType(name = "NMTOKENS")
                        protected List<String> configGroups;
                        /**
                         * Length of the bit string, required if the format is bitString
                         * 
                         */
                        @XmlAttribute(name = "bitStringLength", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlSchemaType(name = "nonNegativeInteger")
                        protected BigInteger bitStringLength;
                        /**
                         * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                         * 
                         */
                        @XmlAttribute(name = "minimum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String minimum;
                        /**
                         * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                         * 
                         */
                        @XmlAttribute(name = "maximum", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String maximum;
                        /**
                         * Determines how a property value is resolved.
                         * 
                         */
                        @XmlAttribute(name = "resolve", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected ResolveType resolve;
                        /**
                         * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                         * 
                         */
                        @XmlAttribute(name = "id", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
                        @XmlID
                        @XmlSchemaType(name = "ID")
                        protected String id;
                        /**
                         * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                         * 
                         */
                        @XmlAttribute(name = "dependency", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
                        protected String dependency;
                        @XmlAnyAttribute
                        private Map<QName, String> otherAttributes = new HashMap<>();

                        /**
                         * Gets the value of the value property.
                         * 
                         * @return
                         *     possible object is
                         *     {@link BigInteger }
                         *     
                         */
                        public BigInteger getValue() {
                            return value;
                        }

                        /**
                         * Sets the value of the value property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link BigInteger }
                         *     
                         */
                        public void setValue(BigInteger value) {
                            this.value = value;
                        }

                        /**
                         * Provides a string used to prompt the user for user-resolved property values.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getPrompt() {
                            return prompt;
                        }

                        /**
                         * Sets the value of the prompt property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getPrompt()
                         */
                        public void setPrompt(String value) {
                            this.prompt = value;
                        }

                        /**
                         * This is an indication on the format of the value for user defined properties.  bitString means a double quoted string of 1's an 0's, the input maybe in this format or a scaledInteger number. A bitStringLength attribute is required for bitString formats. bool means a boolean (true, false) is expected.  float means a decimal floating point number is expected.  long means an value of scaledInteger is expected.  String means any text is acceptable.
                         * 
                         * @return
                         *     possible object is
                         *     {@link FormatType }
                         *     
                         */
                        public FormatType getFormat() {
                            if (format == null) {
                                return FormatType.LONG;
                            } else {
                                return format;
                            }
                        }

                        /**
                         * Sets the value of the format property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link FormatType }
                         *     
                         * @see #getFormat()
                         */
                        public void setFormat(FormatType value) {
                            this.format = value;
                        }

                        /**
                         * Indicates the data type of the range attributes (minimum and maximum). For reasons of backward compatibility, this attribute is assumed to have the value 'float' if not present.
                         * 
                         * @return
                         *     possible object is
                         *     {@link RangeTypeType }
                         *     
                         */
                        public RangeTypeType getRangeType() {
                            if (rangeType == null) {
                                return RangeTypeType.FLOAT;
                            } else {
                                return rangeType;
                            }
                        }

                        /**
                         * Sets the value of the rangeType property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link RangeTypeType }
                         *     
                         * @see #getRangeType()
                         */
                        public void setRangeType(RangeTypeType value) {
                            this.rangeType = value;
                        }

                        /**
                         * For user defined properties, refers the choice element enumerating the values to choose from.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getChoiceRef() {
                            return choiceRef;
                        }

                        /**
                         * Sets the value of the choiceRef property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getChoiceRef()
                         */
                        public void setChoiceRef(String value) {
                            this.choiceRef = value;
                        }

                        /**
                         * For components with auto-generated configuration forms, the user-resolved properties with order attibutes will be presented in ascending order.
                         * 
                         * @return
                         *     possible object is
                         *     {@link Float }
                         *     
                         */
                        public Float getOrder() {
                            return order;
                        }

                        /**
                         * Sets the value of the order property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link Float }
                         *     
                         * @see #getOrder()
                         */
                        public void setOrder(Float value) {
                            this.order = value;
                        }

                        /**
                         * Tags configurable properties so that they may be grouped together.  Configurable properties with matching values for this attribute are contained in the same group. The format of this attribute is a string. There is no semantic meaning to this attribute.
                         * 
                         * Gets the value of the configGroups property.
                         * 
                         * <p>This accessor method returns a reference to the live list,
                         * not a snapshot. Therefore any modification you make to the
                         * returned list will be present inside the JAXB object.
                         * This is why there is not a <CODE>set</CODE> method for the configGroups property.</p>
                         * 
                         * <p>
                         * For example, to add a new item, do as follows:
                         * </p>
                         * <pre>
                         * getConfigGroups().add(newItem);
                         * </pre>
                         * 
                         * 
                         * <p>
                         * Objects of the following type(s) are allowed in the list
                         * {@link String }
                         * </p>
                         * 
                         * 
                         * @return
                         *     The value of the configGroups property.
                         */
                        public List<String> getConfigGroups() {
                            if (configGroups == null) {
                                configGroups = new ArrayList<>();
                            }
                            return this.configGroups;
                        }

                        /**
                         * Length of the bit string, required if the format is bitString
                         * 
                         * @return
                         *     possible object is
                         *     {@link BigInteger }
                         *     
                         */
                        public BigInteger getBitStringLength() {
                            return bitStringLength;
                        }

                        /**
                         * Sets the value of the bitStringLength property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link BigInteger }
                         *     
                         * @see #getBitStringLength()
                         */
                        public void setBitStringLength(BigInteger value) {
                            this.bitStringLength = value;
                        }

                        /**
                         * For user-resolved properties with numeric values, this indicates the minimum value allowed. Only valid for formats long and float.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getMinimum() {
                            return minimum;
                        }

                        /**
                         * Sets the value of the minimum property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getMinimum()
                         */
                        public void setMinimum(String value) {
                            this.minimum = value;
                        }

                        /**
                         * For user-resolved properties with numeric values, this indicates the maximum value allowed. Only valid for formats long and float
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getMaximum() {
                            return maximum;
                        }

                        /**
                         * Sets the value of the maximum property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getMaximum()
                         */
                        public void setMaximum(String value) {
                            this.maximum = value;
                        }

                        /**
                         * Determines how a property value is resolved.
                         * 
                         * @return
                         *     possible object is
                         *     {@link ResolveType }
                         *     
                         */
                        public ResolveType getResolve() {
                            if (resolve == null) {
                                return ResolveType.IMMEDIATE;
                            } else {
                                return resolve;
                            }
                        }

                        /**
                         * Sets the value of the resolve property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link ResolveType }
                         *     
                         * @see #getResolve()
                         */
                        public void setResolve(ResolveType value) {
                            this.resolve = value;
                        }

                        /**
                         * ID attribute for uniquely identifying an element within its document. On elements with spirit:resolve attribute is used to refer to this element and otherwise can be used as a documentation ID.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getId() {
                            return id;
                        }

                        /**
                         * Sets the value of the id property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getId()
                         */
                        public void setId(String value) {
                            this.id = value;
                        }

                        /**
                         * Required on properties with a resolve = "dependent" attribute.  This is an XPath expression supplying the resultant value for the containing element in terms of other properties in the containing file.
                         * 
                         * @return
                         *     possible object is
                         *     {@link String }
                         *     
                         */
                        public String getDependency() {
                            return dependency;
                        }

                        /**
                         * Sets the value of the dependency property.
                         * 
                         * @param value
                         *     allowed object is
                         *     {@link String }
                         *     
                         * @see #getDependency()
                         */
                        public void setDependency(String value) {
                            this.dependency = value;
                        }

                        /**
                         * Gets a map that contains attributes that aren't bound to any typed property on this class.
                         * 
                         * <p>
                         * the map is keyed by the name of the attribute and 
                         * the value is the string value of the attribute.
                         * 
                         * the map returned by this method is live, and you can add new attribute
                         * by updating the map directly. Because of this design, there's no setter.
                         * 
                         * 
                         * @return
                         *     always non-null
                         */
                        public Map<QName, String> getOtherAttributes() {
                            return otherAttributes;
                        }

                    }

                }

            }


            /**
             * <p>Java class for anonymous complex type</p>.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.</p>
             * 
             * <pre>{@code
             * <complexType>
             *   <complexContent>
             *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
             *       <sequence>
             *         <element name="name" type="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}portName"/>
             *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vector" minOccurs="0"/>
             *       </sequence>
             *     </restriction>
             *   </complexContent>
             * </complexType>
             * }</pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "name",
                "vector"
            })
            public static class PhysicalPort {

                /**
                 * Component port name as specified inside the model port section
                 * 
                 */
                @XmlElement(required = true)
                protected String name;
                /**
                 * Definition of the indecies for a vectored port.
                 * 
                 */
                protected org.example.schema.s1685_2009.Vector vector;

                /**
                 * Component port name as specified inside the model port section
                 * 
                 * @return
                 *     possible object is
                 *     {@link String }
                 *     
                 */
                public String getName() {
                    return name;
                }

                /**
                 * Sets the value of the name property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link String }
                 *     
                 * @see #getName()
                 */
                public void setName(String value) {
                    this.name = value;
                }

                /**
                 * Definition of the indecies for a vectored port.
                 * 
                 * @return
                 *     possible object is
                 *     {@link org.example.schema.s1685_2009.Vector }
                 *     
                 */
                public org.example.schema.s1685_2009.Vector getVector() {
                    return vector;
                }

                /**
                 * Sets the value of the vector property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link org.example.schema.s1685_2009.Vector }
                 *     
                 * @see #getVector()
                 */
                public void setVector(org.example.schema.s1685_2009.Vector value) {
                    this.vector = value;
                }

            }

        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}memoryMapRef" minOccurs="0"/>
     *         <element name="bridge" maxOccurs="unbounded" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <attribute name="masterRef" use="required" type="{http://www.w3.org/2001/XMLSchema}Name" />
     *                 <attribute name="opaque" use="required" type="{http://www.w3.org/2001/XMLSchema}boolean" />
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *         <element name="fileSetRefGroup" maxOccurs="unbounded" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <sequence>
     *                   <element name="group" type="{http://www.w3.org/2001/XMLSchema}Name" minOccurs="0"/>
     *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}fileSetRef" maxOccurs="unbounded" minOccurs="0"/>
     *                 </sequence>
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "memoryMapRef",
        "bridge",
        "fileSetRefGroup"
    })
    public static class Slave {

        /**
         * References the memory map. The name of the memory map is kept in its memoryMapRef attribute.
         * 
         */
        protected MemoryMapRefType memoryMapRef;
        /**
         * If this element is present, it indicates that the bus interface provides a bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.  It also has an opaque attribute to indicate that the bus bridge is opaque.
         * 
         * Any slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.
         * 
         */
        protected List<BusInterfaceType.Slave.Bridge> bridge;
        /**
         * This reference is used to point the filesets that are associated with this slave port.
         * 
         * Depending on the slave port function, there may be completely different software drivers associated with the different ports.
         * 
         */
        protected List<BusInterfaceType.Slave.FileSetRefGroup> fileSetRefGroup;

        /**
         * References the memory map. The name of the memory map is kept in its memoryMapRef attribute.
         * 
         * @return
         *     possible object is
         *     {@link MemoryMapRefType }
         *     
         */
        public MemoryMapRefType getMemoryMapRef() {
            return memoryMapRef;
        }

        /**
         * Sets the value of the memoryMapRef property.
         * 
         * @param value
         *     allowed object is
         *     {@link MemoryMapRefType }
         *     
         * @see #getMemoryMapRef()
         */
        public void setMemoryMapRef(MemoryMapRefType value) {
            this.memoryMapRef = value;
        }

        /**
         * If this element is present, it indicates that the bus interface provides a bridge to another master bus interface on the same component.  It has a masterRef attribute which contains the name of the other bus interface.  It also has an opaque attribute to indicate that the bus bridge is opaque.
         * 
         * Any slave interface can bridge to multiple master interfaces, and multiple slave interfaces can bridge to the same master interface.
         * 
         * Gets the value of the bridge property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the bridge property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getBridge().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link BusInterfaceType.Slave.Bridge }
         * </p>
         * 
         * 
         * @return
         *     The value of the bridge property.
         */
        public List<BusInterfaceType.Slave.Bridge> getBridge() {
            if (bridge == null) {
                bridge = new ArrayList<>();
            }
            return this.bridge;
        }

        /**
         * This reference is used to point the filesets that are associated with this slave port.
         * 
         * Depending on the slave port function, there may be completely different software drivers associated with the different ports.
         * 
         * Gets the value of the fileSetRefGroup property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the fileSetRefGroup property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getFileSetRefGroup().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link BusInterfaceType.Slave.FileSetRefGroup }
         * </p>
         * 
         * 
         * @return
         *     The value of the fileSetRefGroup property.
         */
        public List<BusInterfaceType.Slave.FileSetRefGroup> getFileSetRefGroup() {
            if (fileSetRefGroup == null) {
                fileSetRefGroup = new ArrayList<>();
            }
            return this.fileSetRefGroup;
        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <attribute name="masterRef" use="required" type="{http://www.w3.org/2001/XMLSchema}Name" />
         *       <attribute name="opaque" use="required" type="{http://www.w3.org/2001/XMLSchema}boolean" />
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class Bridge {

            /**
             * The name of the master bus interface to which this interface bridges.
             * 
             */
            @XmlAttribute(name = "masterRef", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009", required = true)
            @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
            @XmlSchemaType(name = "Name")
            protected String masterRef;
            /**
             * If true, then this bridge is opaque; the whole of the address range is mappeed by the bridge and there are no gaps.
             * 
             */
            @XmlAttribute(name = "opaque", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009", required = true)
            protected boolean opaque;

            /**
             * The name of the master bus interface to which this interface bridges.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getMasterRef() {
                return masterRef;
            }

            /**
             * Sets the value of the masterRef property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             * @see #getMasterRef()
             */
            public void setMasterRef(String value) {
                this.masterRef = value;
            }

            /**
             * If true, then this bridge is opaque; the whole of the address range is mappeed by the bridge and there are no gaps.
             * 
             */
            public boolean isOpaque() {
                return opaque;
            }

            /**
             * Sets the value of the opaque property.
             * 
             */
            public void setOpaque(boolean value) {
                this.opaque = value;
            }

        }


        /**
         * <p>Java class for anonymous complex type</p>.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.</p>
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <sequence>
         *         <element name="group" type="{http://www.w3.org/2001/XMLSchema}Name" minOccurs="0"/>
         *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}fileSetRef" maxOccurs="unbounded" minOccurs="0"/>
         *       </sequence>
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "group",
            "fileSetRef"
        })
        public static class FileSetRefGroup {

            /**
             * Abritray name assigned to the collections of fileSets.
             * 
             */
            @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
            @XmlSchemaType(name = "Name")
            protected String group;
            /**
             * A reference to a fileSet.
             * 
             */
            protected List<FileSetRef> fileSetRef;

            /**
             * Abritray name assigned to the collections of fileSets.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getGroup() {
                return group;
            }

            /**
             * Sets the value of the group property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             * @see #getGroup()
             */
            public void setGroup(String value) {
                this.group = value;
            }

            /**
             * A reference to a fileSet.
             * 
             * Gets the value of the fileSetRef property.
             * 
             * <p>This accessor method returns a reference to the live list,
             * not a snapshot. Therefore any modification you make to the
             * returned list will be present inside the JAXB object.
             * This is why there is not a <CODE>set</CODE> method for the fileSetRef property.</p>
             * 
             * <p>
             * For example, to add a new item, do as follows:
             * </p>
             * <pre>
             * getFileSetRef().add(newItem);
             * </pre>
             * 
             * 
             * <p>
             * Objects of the following type(s) are allowed in the list
             * {@link FileSetRef }
             * </p>
             * 
             * 
             * @return
             *     The value of the fileSetRef property.
             */
            public List<FileSetRef> getFileSetRef() {
                if (fileSetRef == null) {
                    fileSetRef = new ArrayList<>();
                }
                return this.fileSetRef;
            }

        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}group"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "group"
    })
    public static class System {

        /**
         * Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.
         * 
         */
        @XmlElement(required = true)
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlSchemaType(name = "Name")
        protected String group;

        /**
         * Indicates which system interface is being mirrored. Name must match a group name present on one or more ports in the corresonding bus definition.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getGroup() {
            return group;
        }

        /**
         * Sets the value of the group property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getGroup()
         */
        public void setGroup(String value) {
            this.group = value;
        }

    }

}
