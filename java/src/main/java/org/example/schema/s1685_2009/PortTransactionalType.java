//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.example.schema.s1685_2009;

import java.math.BigInteger;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;


/**
 * Transactional port type.
 * 
 * <p>Java class for portTransactionalType complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="portTransactionalType">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}transTypeDef" minOccurs="0"/>
 *         <element name="service">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}initiative"/>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}serviceTypeDefs" minOccurs="0"/>
 *                   <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element name="connection" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="maxConnections" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" minOccurs="0"/>
 *                   <element name="minConnections" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *       </sequence>
 *       <attribute name="allLogicalInitiativesAllowed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "portTransactionalType", propOrder = {
    "transTypeDef",
    "service",
    "connection"
})
public class PortTransactionalType {

    /**
     * Definition of the port type expressed in the default language for this port (i.e. SystemC or SystemV).
     * 
     */
    protected TransTypeDef transTypeDef;
    /**
     * Describes the interface protocol.
     * 
     */
    @XmlElement(required = true)
    protected PortTransactionalType.Service service;
    /**
     * Bounds number of legal connections.
     * 
     */
    protected PortTransactionalType.Connection connection;
    /**
     * True if logical ports with different initiatives from the physical port initiative may be mapped onto this port. Forbidden for phantom ports, which always allow logical ports with all initiatives value to be mapped onto the physical port. Also ignored for "both" ports, since any logical port may be mapped to a physical "both" port.
     * 
     */
    @XmlAttribute(name = "allLogicalInitiativesAllowed", namespace = "http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009")
    protected Boolean allLogicalInitiativesAllowed;

    /**
     * Definition of the port type expressed in the default language for this port (i.e. SystemC or SystemV).
     * 
     * @return
     *     possible object is
     *     {@link TransTypeDef }
     *     
     */
    public TransTypeDef getTransTypeDef() {
        return transTypeDef;
    }

    /**
     * Sets the value of the transTypeDef property.
     * 
     * @param value
     *     allowed object is
     *     {@link TransTypeDef }
     *     
     * @see #getTransTypeDef()
     */
    public void setTransTypeDef(TransTypeDef value) {
        this.transTypeDef = value;
    }

    /**
     * Describes the interface protocol.
     * 
     * @return
     *     possible object is
     *     {@link PortTransactionalType.Service }
     *     
     */
    public PortTransactionalType.Service getService() {
        return service;
    }

    /**
     * Sets the value of the service property.
     * 
     * @param value
     *     allowed object is
     *     {@link PortTransactionalType.Service }
     *     
     * @see #getService()
     */
    public void setService(PortTransactionalType.Service value) {
        this.service = value;
    }

    /**
     * Bounds number of legal connections.
     * 
     * @return
     *     possible object is
     *     {@link PortTransactionalType.Connection }
     *     
     */
    public PortTransactionalType.Connection getConnection() {
        return connection;
    }

    /**
     * Sets the value of the connection property.
     * 
     * @param value
     *     allowed object is
     *     {@link PortTransactionalType.Connection }
     *     
     * @see #getConnection()
     */
    public void setConnection(PortTransactionalType.Connection value) {
        this.connection = value;
    }

    /**
     * True if logical ports with different initiatives from the physical port initiative may be mapped onto this port. Forbidden for phantom ports, which always allow logical ports with all initiatives value to be mapped onto the physical port. Also ignored for "both" ports, since any logical port may be mapped to a physical "both" port.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAllLogicalInitiativesAllowed() {
        if (allLogicalInitiativesAllowed == null) {
            return false;
        } else {
            return allLogicalInitiativesAllowed;
        }
    }

    /**
     * Sets the value of the allLogicalInitiativesAllowed property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     * @see #isAllLogicalInitiativesAllowed()
     */
    public void setAllLogicalInitiativesAllowed(Boolean value) {
        this.allLogicalInitiativesAllowed = value;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="maxConnections" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" minOccurs="0"/>
     *         <element name="minConnections" type="{http://www.w3.org/2001/XMLSchema}nonNegativeInteger" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "maxConnections",
        "minConnections"
    })
    public static class Connection {

        /**
         * Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.
         * 
         */
        @XmlElement(defaultValue = "0")
        @XmlSchemaType(name = "nonNegativeInteger")
        protected BigInteger maxConnections;
        /**
         * Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.
         * 
         */
        @XmlElement(defaultValue = "1")
        @XmlSchemaType(name = "nonNegativeInteger")
        protected BigInteger minConnections;

        /**
         * Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.
         * 
         * @return
         *     possible object is
         *     {@link BigInteger }
         *     
         */
        public BigInteger getMaxConnections() {
            return maxConnections;
        }

        /**
         * Sets the value of the maxConnections property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigInteger }
         *     
         * @see #getMaxConnections()
         */
        public void setMaxConnections(BigInteger value) {
            this.maxConnections = value;
        }

        /**
         * Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.
         * 
         * @return
         *     possible object is
         *     {@link BigInteger }
         *     
         */
        public BigInteger getMinConnections() {
            return minConnections;
        }

        /**
         * Sets the value of the minConnections property.
         * 
         * @param value
         *     allowed object is
         *     {@link BigInteger }
         *     
         * @see #getMinConnections()
         */
        public void setMinConnections(BigInteger value) {
            this.minConnections = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}initiative"/>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}serviceTypeDefs" minOccurs="0"/>
     *         <element ref="{http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009}vendorExtensions" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "initiative",
        "serviceTypeDefs",
        "vendorExtensions"
    })
    public static class Service {

        /**
         * Defines how the port accesses this service.
         * 
         */
        @XmlElement(required = true)
        protected String initiative;
        /**
         * The group of service type definitions.
         * 
         */
        protected ServiceTypeDefs serviceTypeDefs;
        /**
         * Container for vendor specific extensions.
         * 
         */
        protected VendorExtensions vendorExtensions;

        /**
         * Defines how the port accesses this service.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getInitiative() {
            return initiative;
        }

        /**
         * Sets the value of the initiative property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         * @see #getInitiative()
         */
        public void setInitiative(String value) {
            this.initiative = value;
        }

        /**
         * The group of service type definitions.
         * 
         * @return
         *     possible object is
         *     {@link ServiceTypeDefs }
         *     
         */
        public ServiceTypeDefs getServiceTypeDefs() {
            return serviceTypeDefs;
        }

        /**
         * Sets the value of the serviceTypeDefs property.
         * 
         * @param value
         *     allowed object is
         *     {@link ServiceTypeDefs }
         *     
         * @see #getServiceTypeDefs()
         */
        public void setServiceTypeDefs(ServiceTypeDefs value) {
            this.serviceTypeDefs = value;
        }

        /**
         * Container for vendor specific extensions.
         * 
         * @return
         *     possible object is
         *     {@link VendorExtensions }
         *     
         */
        public VendorExtensions getVendorExtensions() {
            return vendorExtensions;
        }

        /**
         * Sets the value of the vendorExtensions property.
         * 
         * @param value
         *     allowed object is
         *     {@link VendorExtensions }
         *     
         * @see #getVendorExtensions()
         */
        public void setVendorExtensions(VendorExtensions value) {
            this.vendorExtensions = value;
        }

    }

}
