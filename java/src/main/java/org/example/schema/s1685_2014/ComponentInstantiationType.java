//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.5 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package org.example.schema.s1685_2014;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlID;
import jakarta.xml.bind.annotation.XmlSchemaType;
import jakarta.xml.bind.annotation.XmlType;
import jakarta.xml.bind.annotation.adapters.CollapsedStringAdapter;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;


/**
 * Component instantiation type
 * 
 * <p>Java class for componentInstantiationType complex type</p>.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.</p>
 * 
 * <pre>{@code
 * <complexType name="componentInstantiationType">
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <group ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}nameGroupNMTOKEN"/>
 *         <element name="isVirtual" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/>
 *         <element name="language" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}languageType" minOccurs="0"/>
 *         <element name="libraryName" type="{http://www.w3.org/2001/XMLSchema}anyType" minOccurs="0"/>
 *         <element name="packageName" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         <element name="moduleName" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         <element name="architectureName" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         <element name="configurationName" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         <element name="moduleParameters" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="moduleParameter" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}moduleParameterType" maxOccurs="unbounded"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element name="defaultFileBuilder" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileBuilderType" maxOccurs="unbounded" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}fileSetRef" maxOccurs="unbounded" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}constraintSetRef" maxOccurs="unbounded" minOccurs="0"/>
 *         <element name="whiteboxElementRefs" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="whiteboxElementRef" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElementRefType" maxOccurs="unbounded" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}parameters" minOccurs="0"/>
 *         <element ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}vendorExtensions" minOccurs="0"/>
 *       </sequence>
 *       <attGroup ref="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}id.att"/>
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "componentInstantiationType", propOrder = {
    "name",
    "displayName",
    "description",
    "isVirtual",
    "language",
    "libraryName",
    "packageName",
    "moduleName",
    "architectureName",
    "configurationName",
    "moduleParameters",
    "defaultFileBuilder",
    "fileSetRef",
    "constraintSetRef",
    "whiteboxElementRefs",
    "parameters",
    "vendorExtensions"
})
public class ComponentInstantiationType {

    /**
     * Unique name
     * 
     */
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlSchemaType(name = "NMTOKEN")
    protected String name;
    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.
     * 
     */
    protected String displayName;
    /**
     * Full description string, typically for documentation
     * 
     */
    protected String description;
    /**
     * When true, indicates that this component should not be netlisted.
     * 
     */
    @XmlElement(defaultValue = "false")
    protected Boolean isVirtual;
    /**
     * The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.
     * 
     */
    protected LanguageType language;
    /**
     * A string specifying the library name in which the model should be compiled. If the libraryName element is not present then its value defaults to “work”.
     * 
     */
    protected Object libraryName;
    /**
     * A string describing the VHDL package containing the interface of the model. If the packageName element is not present then its value defaults to the component VLNV name concatenated with postfix “_cmp_pkg” which stands for component package.
     * 
     */
    protected String packageName;
    /**
     * A string describing the Verilog, SystemVerilog, or SystemC module name or the VHDL entity name. If the moduleName is not present then its value defaults to the component VLNV name
     * 
     */
    protected String moduleName;
    /**
     * A string describing the VHDL architecture name. If the architectureName element is not present then its value defaults to “rtl”.
     * 
     */
    protected String architectureName;
    /**
     * A string describing the Verilog, SystemVerilog, or VHDL configuration name. If the configurationName element is not present then its value defaults to the design configuration VLNV name of the design configuration associated with the active hierarchical view or, if there is no active hierarchical view, to the component VLNV name concatenated with postfix “_rtl_cfg”.
     * 
     */
    protected String configurationName;
    /**
     * Model parameter name value pairs container
     * 
     */
    protected ComponentInstantiationType.ModuleParameters moduleParameters;
    /**
     * Default command and flags used to build derived files from the sourceName files in the referenced file sets.
     * 
     */
    protected List<FileBuilderType> defaultFileBuilder;
    /**
     * A reference to a fileSet.
     * 
     */
    protected List<FileSetRef> fileSetRef;
    /**
     * A reference to a set of port constraints.
     * 
     */
    protected List<ConstraintSetRef> constraintSetRef;
    /**
     * Container for white box element references.
     * 
     */
    protected ComponentInstantiationType.WhiteboxElementRefs whiteboxElementRefs;
    /**
     * A collection of parameters and associated value assertions.
     * 
     */
    protected Parameters parameters;
    /**
     * Container for vendor specific extensions.
     * 
     */
    protected VendorExtensions vendorExtensions;
    /**
     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
     * 
     */
    @XmlAttribute(name = "id", namespace = "http://www.w3.org/XML/1998/namespace")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected String id;

    /**
     * Unique name
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getName() {
        return name;
    }

    /**
     * Sets the value of the name property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getName()
     */
    public void setName(String value) {
        this.name = value;
    }

    /**
     * Element name for display purposes. Typically a few words providing a more detailed and/or user-friendly name than the ipxact:name.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Sets the value of the displayName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDisplayName()
     */
    public void setDisplayName(String value) {
        this.displayName = value;
    }

    /**
     * Full description string, typically for documentation
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getDescription()
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * When true, indicates that this component should not be netlisted.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isIsVirtual() {
        return isVirtual;
    }

    /**
     * Sets the value of the isVirtual property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     * @see #isIsVirtual()
     */
    public void setIsVirtual(Boolean value) {
        this.isVirtual = value;
    }

    /**
     * The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.
     * 
     * @return
     *     possible object is
     *     {@link LanguageType }
     *     
     */
    public LanguageType getLanguage() {
        return language;
    }

    /**
     * Sets the value of the language property.
     * 
     * @param value
     *     allowed object is
     *     {@link LanguageType }
     *     
     * @see #getLanguage()
     */
    public void setLanguage(LanguageType value) {
        this.language = value;
    }

    /**
     * A string specifying the library name in which the model should be compiled. If the libraryName element is not present then its value defaults to “work”.
     * 
     * @return
     *     possible object is
     *     {@link Object }
     *     
     */
    public Object getLibraryName() {
        return libraryName;
    }

    /**
     * Sets the value of the libraryName property.
     * 
     * @param value
     *     allowed object is
     *     {@link Object }
     *     
     * @see #getLibraryName()
     */
    public void setLibraryName(Object value) {
        this.libraryName = value;
    }

    /**
     * A string describing the VHDL package containing the interface of the model. If the packageName element is not present then its value defaults to the component VLNV name concatenated with postfix “_cmp_pkg” which stands for component package.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getPackageName() {
        return packageName;
    }

    /**
     * Sets the value of the packageName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getPackageName()
     */
    public void setPackageName(String value) {
        this.packageName = value;
    }

    /**
     * A string describing the Verilog, SystemVerilog, or SystemC module name or the VHDL entity name. If the moduleName is not present then its value defaults to the component VLNV name
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getModuleName() {
        return moduleName;
    }

    /**
     * Sets the value of the moduleName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getModuleName()
     */
    public void setModuleName(String value) {
        this.moduleName = value;
    }

    /**
     * A string describing the VHDL architecture name. If the architectureName element is not present then its value defaults to “rtl”.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getArchitectureName() {
        return architectureName;
    }

    /**
     * Sets the value of the architectureName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getArchitectureName()
     */
    public void setArchitectureName(String value) {
        this.architectureName = value;
    }

    /**
     * A string describing the Verilog, SystemVerilog, or VHDL configuration name. If the configurationName element is not present then its value defaults to the design configuration VLNV name of the design configuration associated with the active hierarchical view or, if there is no active hierarchical view, to the component VLNV name concatenated with postfix “_rtl_cfg”.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getConfigurationName() {
        return configurationName;
    }

    /**
     * Sets the value of the configurationName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getConfigurationName()
     */
    public void setConfigurationName(String value) {
        this.configurationName = value;
    }

    /**
     * Model parameter name value pairs container
     * 
     * @return
     *     possible object is
     *     {@link ComponentInstantiationType.ModuleParameters }
     *     
     */
    public ComponentInstantiationType.ModuleParameters getModuleParameters() {
        return moduleParameters;
    }

    /**
     * Sets the value of the moduleParameters property.
     * 
     * @param value
     *     allowed object is
     *     {@link ComponentInstantiationType.ModuleParameters }
     *     
     * @see #getModuleParameters()
     */
    public void setModuleParameters(ComponentInstantiationType.ModuleParameters value) {
        this.moduleParameters = value;
    }

    /**
     * Default command and flags used to build derived files from the sourceName files in the referenced file sets.
     * 
     * Gets the value of the defaultFileBuilder property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the defaultFileBuilder property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getDefaultFileBuilder().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FileBuilderType }
     * </p>
     * 
     * 
     * @return
     *     The value of the defaultFileBuilder property.
     */
    public List<FileBuilderType> getDefaultFileBuilder() {
        if (defaultFileBuilder == null) {
            defaultFileBuilder = new ArrayList<>();
        }
        return this.defaultFileBuilder;
    }

    /**
     * A reference to a fileSet.
     * 
     * Gets the value of the fileSetRef property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fileSetRef property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getFileSetRef().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FileSetRef }
     * </p>
     * 
     * 
     * @return
     *     The value of the fileSetRef property.
     */
    public List<FileSetRef> getFileSetRef() {
        if (fileSetRef == null) {
            fileSetRef = new ArrayList<>();
        }
        return this.fileSetRef;
    }

    /**
     * A reference to a set of port constraints.
     * 
     * Gets the value of the constraintSetRef property.
     * 
     * <p>This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the constraintSetRef property.</p>
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * </p>
     * <pre>
     * getConstraintSetRef().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConstraintSetRef }
     * </p>
     * 
     * 
     * @return
     *     The value of the constraintSetRef property.
     */
    public List<ConstraintSetRef> getConstraintSetRef() {
        if (constraintSetRef == null) {
            constraintSetRef = new ArrayList<>();
        }
        return this.constraintSetRef;
    }

    /**
     * Container for white box element references.
     * 
     * @return
     *     possible object is
     *     {@link ComponentInstantiationType.WhiteboxElementRefs }
     *     
     */
    public ComponentInstantiationType.WhiteboxElementRefs getWhiteboxElementRefs() {
        return whiteboxElementRefs;
    }

    /**
     * Sets the value of the whiteboxElementRefs property.
     * 
     * @param value
     *     allowed object is
     *     {@link ComponentInstantiationType.WhiteboxElementRefs }
     *     
     * @see #getWhiteboxElementRefs()
     */
    public void setWhiteboxElementRefs(ComponentInstantiationType.WhiteboxElementRefs value) {
        this.whiteboxElementRefs = value;
    }

    /**
     * A collection of parameters and associated value assertions.
     * 
     * @return
     *     possible object is
     *     {@link Parameters }
     *     
     */
    public Parameters getParameters() {
        return parameters;
    }

    /**
     * Sets the value of the parameters property.
     * 
     * @param value
     *     allowed object is
     *     {@link Parameters }
     *     
     * @see #getParameters()
     */
    public void setParameters(Parameters value) {
        this.parameters = value;
    }

    /**
     * Container for vendor specific extensions.
     * 
     * @return
     *     possible object is
     *     {@link VendorExtensions }
     *     
     */
    public VendorExtensions getVendorExtensions() {
        return vendorExtensions;
    }

    /**
     * Sets the value of the vendorExtensions property.
     * 
     * @param value
     *     allowed object is
     *     {@link VendorExtensions }
     *     
     * @see #getVendorExtensions()
     */
    public void setVendorExtensions(VendorExtensions value) {
        this.vendorExtensions = value;
    }

    /**
     * A generic mechanism for annotating elements with unique identifiers. See: http://www.w3.org/TR/xml-id/ for more information.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     * @see #getId()
     */
    public void setId(String value) {
        this.id = value;
    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="moduleParameter" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}moduleParameterType" maxOccurs="unbounded"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "moduleParameter"
    })
    public static class ModuleParameters {

        /**
         * A module parameter name value pair. The name is given in an attribute. The value is the element value. The dataType (applicable to high level modeling) is given in the dataType attribute. For hardware based models, the name should be identical to the RTL (VHDL generic or Verilog parameter). The usageType attribute indicates how the model parameter is to be used.
         * 
         */
        @XmlElement(required = true)
        protected List<ModuleParameterType> moduleParameter;

        /**
         * A module parameter name value pair. The name is given in an attribute. The value is the element value. The dataType (applicable to high level modeling) is given in the dataType attribute. For hardware based models, the name should be identical to the RTL (VHDL generic or Verilog parameter). The usageType attribute indicates how the model parameter is to be used.
         * 
         * Gets the value of the moduleParameter property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the moduleParameter property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getModuleParameter().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link ModuleParameterType }
         * </p>
         * 
         * 
         * @return
         *     The value of the moduleParameter property.
         */
        public List<ModuleParameterType> getModuleParameter() {
            if (moduleParameter == null) {
                moduleParameter = new ArrayList<>();
            }
            return this.moduleParameter;
        }

    }


    /**
     * <p>Java class for anonymous complex type</p>.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.</p>
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="whiteboxElementRef" type="{http://www.accellera.org/XMLSchema/IPXACT/1685-2014}whiteboxElementRefType" maxOccurs="unbounded" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "whiteboxElementRef"
    })
    public static class WhiteboxElementRefs {

        /**
         * Reference to a white box element which is visible within this view.
         * 
         */
        protected List<WhiteboxElementRefType> whiteboxElementRef;

        /**
         * Reference to a white box element which is visible within this view.
         * 
         * Gets the value of the whiteboxElementRef property.
         * 
         * <p>This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the whiteboxElementRef property.</p>
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * </p>
         * <pre>
         * getWhiteboxElementRef().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link WhiteboxElementRefType }
         * </p>
         * 
         * 
         * @return
         *     The value of the whiteboxElementRef property.
         */
        public List<WhiteboxElementRefType> getWhiteboxElementRef() {
            if (whiteboxElementRef == null) {
                whiteboxElementRef = new ArrayList<>();
            }
            return this.whiteboxElementRef;
        }

    }

}
